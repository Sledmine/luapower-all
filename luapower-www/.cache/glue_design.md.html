<h2 id="scope">Scope</h2>
<p>A place to accumulate good implementations of common Lua idioms, mainly so that they can be copy-pasted in library code (a typical library only needs a few functions from glue) or used directly in app code (where another dependency is not a problem). In this context a good implementation is first of all small and its corner cases well documented (since they are usually not addressed in the implementation in order to keep the code small and fast).</p>
<h2 id="naming">Naming</h2>
<p>The idea is to find the most popular, familiar and <em>short</em> names for <em>each and every</em> function (no underscores and no capitals). Python gets this right, so does UNIX. A function with an unheard of name or alien semantics will be avoided. People rather recall known names/semantics rather than learn unfamiliar new names/semantics, even when those would be more clear.</p>
<h2 id="semantics">Semantics</h2>
<p>They follow the general <a href="/api-design">api-design</a> rules.</p>
<h3 id="objects-vs-glue">Objects vs glue</h3>
<p>Don’t provide data structures like list and set in a glue library, or a way to do OOP. Instead just provide the mechanisms as functions working on bare tables. Don’t do both either: if your list type gets widely adopted, your programs will now be a mixture of bare tables (this is inevitable) and lists so now you have to decide which of your lists has a <code>sort()</code> method and which need to be wrapped first.</p>
<h3 id="write-in-lua">Write in Lua</h3>
<p>String lambdas, callable strings, list comprehensions are all fun, but they they add syntax and and a learning curve and should be generally avoided in contexts where their use is spare.</p>
<h3 id="sugar">Sugar</h3>
<p>Don’t add shortcut functions except when calling the shortcut function makes the intent clearer than when reading the equivalent Lua code.</p>
<p>If something is an <a href="/lua-tricks">idiom</a>, don’t add a function for it, use it directly. Chances are its syntax will be more popular than its name. Eg. it’s harder to recall and trust semantic equivalence of <code>isnan(x)</code> to the odd looking but mnemonic idiom <code>x ~= x</code> (eg. does <code>isnan</code> raise an error when <code>x</code> is not a number?). That doesn’t mean <code>a &lt; b and a or b</code> is a good idiom for <code>math.min(a, b)</code> though, <code>min()</code> itself is the idiom as we know it from math (<code>sign()</code>, <code>clamp()</code>, etc. are idioms too).</p>
<p>Functional programming sugars like <code>compose</code> and <code>bind</code> makes code harder to read because brains are slow to switch between abstraction levels unless it’s a self-contained DSL with radically different syntax and semantics than the surrounding code. Eg. it’s easier to read a Lua string pattern or an embedded SQL string than it is to read expressions involving <code>bind</code> and <code>compose</code> which force you to simulate the equivalent Lua syntax in your head.</p>
<p>Sugars like “message %s” % arg are the good ones: % is odd enough to put after a string constant that it has an idiomatic quality, and its semantics is self-evident by reading the format string literal, even for someone who never heard of python’s <code>%</code> operator. Also, a prefix notation is generally more readable than a function call.</p>
<h2 id="implementation">Implementation</h2>
<p>Keep the code readable and compact. Code changes that compromise these qualities for optimization should come with a benchmark to justify them.</p>
<p>Document the limits of the algorithms involved with respect to input, like when does it have non-linear performance and if and how it is stack bound. Performance characteristics are not an implementation detail.</p>
