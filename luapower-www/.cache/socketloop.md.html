<h2 id="local-loop-requiresocketloop"><code>local loop = require'socketloop'</code></h2>
<p>A socket loop enables coroutine-based asynchronous I/O programming model for <a href="http://w3.impa.br/~diego/software/luasocket/tcp.html">TCP sockets</a>. The concept is similar to <a href="http://keplerproject.github.com/copas/">Copas</a>, the API and the implementation are different. Supports both <a href="/coro">symmetric</a> and asymmetric coroutines.</p>
<h2 id="api">API</h2>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>loop.wrap(socket|fd) -&gt; asocket</code></td>
<td>wrap a TCP socket or a fd to an async socket</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>loop.connect(host, port, [local_ip], [local_port]) -&gt; asocket</code></td>
<td>make an async TCP connection</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>loop.tcp([local_ip], [local_port]) -&gt; asocket</code></td>
<td>create an async TCP socket</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>loop.newthread(handler, arg)</code></td>
<td>create a thread for one connection</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>loop.current() -&gt; thread</code></td>
<td>current thread</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>loop.suspend()</code></td>
<td>suspend current thread</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>loop.resume(thread, arg)</code></td>
<td>resume a suspended thread</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>loop.newserver(ip, port, handler) -&gt; skt</code></td>
<td>dispatch inbound connections to a function</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>loop.start([timeout])</code></td>
<td>start the loop</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>loop.stop()</code></td>
<td>stop the loop (if started)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>loop.step([timeout]) -&gt; true|false</code></td>
<td>dispatch pending reads and writes</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>loop.coro -&gt; loop</code></td>
<td><a href="/coro">coro</a>-based loop</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>asocket:call_async(func, ...) -&gt; ret, err</code></td>
<td>call a multi-step async function</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>asocket:getsocket() -&gt; socket</code></td>
<td>get the wrapped LuaSocket</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>asocket:setsocket(socket)</code></td>
<td>set the wrapped LuaSocket</td>
</tr>
</tbody>
</table>
<h3 id="loop.wrapsocket---asocket"><code>loop.wrap(socket) -&gt; asocket</code></h3>
<p>Wrap a <a href="http://w3.impa.br/~diego/software/luasocket/tcp.html">TCP socket</a> into an asynchronous socket with the same API as the original, which btw is kept as <code>asocket.socket</code>.</p>
<p>Being asynchronous means that if each socket is used from its own coroutine, different sockets won’t block each other waiting for reads and writes, as long as the loop is doing the dispatching. The asynchronous methods are: <code>connect()</code>, <code>accept()</code>, <code>receive()</code>, <code>send()</code>, <code>close()</code>.</p>
<p>An async socket should only be used inside a loop thread.</p>
<h3 id="loop.connecthost-port-local_ip-local_port---asocket"><code>loop.connect(host, port, [local_ip], [local_port]) -&gt; asocket</code></h3>
<p>Make a TCP connection and return an async socket.</p>
<h3 id="loop.tcplocal_ip-local_port---asocket"><code>loop.tcp([local_ip], [local_port]) -&gt; asocket</code></h3>
<p>Create an async TCP socket optionally binding it to a specific local IP and port.</p>
<h3 id="loop.newthreadhandler-arg---thread"><code>loop.newthread(handler, arg) -&gt; thread</code></h3>
<p>Create and resume a thead (either a coroutine or a coro thread). The thread is suspended and control returns to the caller as soon as:</p>
<ul>
<li>an async socket method is called,</li>
<li><code>loop.suspend()</code> is called,</li>
<li>the thread finishes.</li>
</ul>
<h3 id="loop.current---thread"><code>loop.current() -&gt; thread</code></h3>
<p>Return the current thread (either a coroutine or a coro thread).</p>
<h3 id="loop.suspend"><code>loop.suspend()</code></h3>
<p>Suspend the current thread. To resume a suspended thread, call <code>loop.resume()</code> from another thread.</p>
<h3 id="loop.resumethread-arg"><code>loop.resume(thread, arg)</code></h3>
<p>Resume a suspended thread without blocking the current thread. The call returns as soon as the thread gets suspended again in an async I/O call or in <code>loop.suspend()</code>.</p>
<p>Only resume threads that were previously suspended by calling <code>loop.suspend()</code>. Resuming a thread that is suspended in an async call is undefined behavior.</p>
<h3 id="loop.newserverip-port-handler"><code>loop.newserver(ip, port, handler)</code></h3>
<p>Create a TCP socket and start accepting connections on it, and call <code>handler(client_skt)</code> on a separate coroutine for each accepted connection.</p>
<h3 id="loop.starttimeout"><code>loop.start([timeout])</code></h3>
<p>Start dispatching reads and writes continuously in a loop. The loop should be started only if there’s at least one thread suspended in an async socket call.</p>
<h3 id="loop.stop"><code>loop.stop()</code></h3>
<p>Stop the dispatch loop (if started).</p>
<h3 id="loop.steptimeout---truefalse"><code>loop.step([timeout]) -&gt; true|false</code></h3>
<p>Dispatch currently pending reads and writes to their respective threads.</p>
<h3 id="loop-requiresocketloop.coro"><code>loop = require'socketloop'.coro</code></h3>
<p>An alternative loop that dispatches to <a href="/coro">symmetric coroutines</a> instead of Lua coroutines.</p>
<h2 id="example">Example</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">local</span> loop <span class="op">=</span> <span class="fu">require</span><span class="st">&#39;socketloop&#39;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">local</span> http <span class="op">=</span> <span class="fu">require</span><span class="st">&#39;socket.http&#39;</span></span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">local</span> <span class="kw">function</span> getpage<span class="op">(</span>url<span class="op">)</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>   <span class="kw">local</span> t <span class="op">=</span> <span class="op">{}</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>   <span class="kw">local</span> ok<span class="op">,</span> code<span class="op">,</span> headers <span class="op">=</span> http<span class="op">.</span>request<span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>      url <span class="op">=</span> url<span class="op">,</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>      sink <span class="op">=</span> ltn12<span class="op">.</span>sink<span class="op">.</span>table<span class="op">(</span>t<span class="op">),</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>      create <span class="op">=</span> <span class="kw">function</span><span class="op">()</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>         <span class="cf">return</span> loop<span class="op">.</span>wrap<span class="op">(</span>socket<span class="op">.</span>try<span class="op">(</span>socket<span class="op">.</span>tcp<span class="op">()))</span></span>
<span id="cb1-11"><a href="#cb1-11"></a>      <span class="cf">end</span><span class="op">,</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>   <span class="op">}</span></span>
<span id="cb1-13"><a href="#cb1-13"></a>   <span class="fu">assert</span><span class="op">(</span>ok<span class="op">,</span> code<span class="op">)</span></span>
<span id="cb1-14"><a href="#cb1-14"></a>   <span class="cf">return</span> <span class="fu">table.concat</span><span class="op">(</span>t<span class="op">),</span> headers<span class="op">,</span> code</span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="cf">end</span></span>
<span id="cb1-16"><a href="#cb1-16"></a></span>
<span id="cb1-17"><a href="#cb1-17"></a>loop<span class="op">.</span>newthread<span class="op">(</span><span class="kw">function</span><span class="op">()</span></span>
<span id="cb1-18"><a href="#cb1-18"></a>   <span class="kw">local</span> body <span class="op">=</span> getpage<span class="st">&#39;http://google.com/&#39;</span></span>
<span id="cb1-19"><a href="#cb1-19"></a>   <span class="fu">print</span><span class="op">(</span><span class="st">&#39;got &#39;</span> <span class="op">..</span> <span class="op">#</span>body <span class="op">..</span> <span class="st">&#39; bytes&#39;</span><span class="op">)</span></span>
<span id="cb1-20"><a href="#cb1-20"></a><span class="cf">end</span><span class="op">)</span></span>
<span id="cb1-21"><a href="#cb1-21"></a></span>
<span id="cb1-22"><a href="#cb1-22"></a>loop<span class="op">.</span>start<span class="op">()</span></span></code></pre></div>
<h3 id="asocketcall_asyncfunc-...---ret-err"><code>asocket:call_async(func, ...) -&gt; ret, err</code></h3>
<p>Call <code>func(...)</code> repeatedly until it doesn’t signal the need to wait for data to read or write anymore. The function performs I/O on <code>asocket</code> and returns <code>nil|false, 'wantread'</code> when it needs to poll for more bytes to read and <code>nil|false, 'wantwrite'</code> when it needs to wait for the write buffer to become accessible for writing.</p>
