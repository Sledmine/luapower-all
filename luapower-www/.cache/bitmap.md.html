<h2 id="local-bitmap-requirebitmap"><code>local bitmap = require'bitmap'</code></h2>
<h2 id="features">Features</h2>
<ul>
<li>multiple pixel formats, color spaces, channel layouts, scanline orderings, row strides, and bit depths.
<ul>
<li>arbitrary row strides, including sub-byte strides.</li>
<li>top-down and bottom-up scanline order.</li>
</ul></li>
<li>conversion between most formats.</li>
<li>reading and writing pixel data in a uniform way, independent of the pixel format.</li>
<li>dithering, pixel effects, filters.</li>
<li>fast (see benchmarks).</li>
</ul>
<h2 id="limitations">Limitations</h2>
<ul>
<li>only packed formats, no separate plane formats
<ul>
<li>but: custom conversions to gray8 and gray16 can be used to separate the channels of any format into separate bitmaps.</li>
</ul></li>
<li>only expanded formats, no palette formats
<ul>
<li>but: custom formats with a custom reader and writer can be easily made to use a palette which itself can be a one-row bitmap.</li>
</ul></li>
<li>no conversions to cmyk (would need color profiling)</li>
<li>no conversions to ycc and ycck</li>
</ul>
<h2 id="whats-a-bitmap">What’s a bitmap?</h2>
<p>A bitmap is a table format, i.e. any table with the following fields is a bitmap:</p>
<ul>
<li><code>w</code>, <code>h</code> - bitmap dimensions, in pixels.</li>
<li><code>stride</code> - row stride in bytes. must be at least <code>w * bpp / 8</code> (can be fractional for &lt; 8bpp formats).</li>
<li><code>bottom_up</code> - if <code>true</code>, the rows are are arranged bottom-up instead of top-down.</li>
<li><code>data</code> - the pixel buffer (string or a cdata buffer). the pixels must be packed in <code>stride</code>-long rows, top-down or bottom-up.</li>
<li><code>size</code> - size of the pixel buffer, in bytes.</li>
<li><code>format</code> - the pixel format, either a string naming a predefined format (below table), or a table specifying a custom format (see customization).</li>
</ul>
<h3 id="predefined-formats">Predefined formats</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>name</strong></th>
<th style="text-align: left;"><strong>colortype</strong></th>
<th style="text-align: left;"><strong>channels</strong></th>
<th style="text-align: left;"><strong>bits/channel</strong></th>
<th style="text-align: left;"><strong>bits/pixel</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">rgb8, bgr8</td>
<td style="text-align: left;">rgba8</td>
<td style="text-align: left;">RGB</td>
<td style="text-align: left;">8</td>
<td style="text-align: left;">24</td>
</tr>
<tr class="even">
<td style="text-align: left;">rgb16, bgr16</td>
<td style="text-align: left;">rgba16</td>
<td style="text-align: left;">RGB</td>
<td style="text-align: left;">16</td>
<td style="text-align: left;">48</td>
</tr>
<tr class="odd">
<td style="text-align: left;">rgbx8, bgrx8, xrgb8, xbgr8</td>
<td style="text-align: left;">rgba8</td>
<td style="text-align: left;">RGB</td>
<td style="text-align: left;">8</td>
<td style="text-align: left;">32</td>
</tr>
<tr class="even">
<td style="text-align: left;">rgbx16, bgrx16, xrgb16, xbgr16</td>
<td style="text-align: left;">rgba16</td>
<td style="text-align: left;">RGB</td>
<td style="text-align: left;">16</td>
<td style="text-align: left;">64</td>
</tr>
<tr class="odd">
<td style="text-align: left;">rgba8, bgra8, argb8, abgr8</td>
<td style="text-align: left;">rgba8</td>
<td style="text-align: left;">RGB+alpha</td>
<td style="text-align: left;">8</td>
<td style="text-align: left;">32</td>
</tr>
<tr class="even">
<td style="text-align: left;">rgba16, bgra16, argb16, abgr16</td>
<td style="text-align: left;">rgba16</td>
<td style="text-align: left;">RGB+alpha</td>
<td style="text-align: left;">16</td>
<td style="text-align: left;">64</td>
</tr>
<tr class="odd">
<td style="text-align: left;">rgb565</td>
<td style="text-align: left;">rgba8</td>
<td style="text-align: left;">RGB</td>
<td style="text-align: left;">5/6/5</td>
<td style="text-align: left;">16</td>
</tr>
<tr class="even">
<td style="text-align: left;">rgb0555</td>
<td style="text-align: left;">rgba8</td>
<td style="text-align: left;">RGB</td>
<td style="text-align: left;">5</td>
<td style="text-align: left;">16</td>
</tr>
<tr class="odd">
<td style="text-align: left;">rgb5550</td>
<td style="text-align: left;">rgba8</td>
<td style="text-align: left;">RGB</td>
<td style="text-align: left;">5</td>
<td style="text-align: left;">16</td>
</tr>
<tr class="even">
<td style="text-align: left;">rgb444</td>
<td style="text-align: left;">rgba8</td>
<td style="text-align: left;">RGB</td>
<td style="text-align: left;">4</td>
<td style="text-align: left;">16</td>
</tr>
<tr class="odd">
<td style="text-align: left;">rgba4444</td>
<td style="text-align: left;">rgba8</td>
<td style="text-align: left;">RGB+alpha</td>
<td style="text-align: left;">4</td>
<td style="text-align: left;">16</td>
</tr>
<tr class="even">
<td style="text-align: left;">rgba5551</td>
<td style="text-align: left;">rgba8</td>
<td style="text-align: left;">RGB+alpha</td>
<td style="text-align: left;">5/5/5/1</td>
<td style="text-align: left;">16</td>
</tr>
<tr class="odd">
<td style="text-align: left;">rgba1555</td>
<td style="text-align: left;">rgba8</td>
<td style="text-align: left;">RGB+alpha</td>
<td style="text-align: left;">1/5/5/5</td>
<td style="text-align: left;">16</td>
</tr>
<tr class="even">
<td style="text-align: left;">ga8, ag8</td>
<td style="text-align: left;">ga8</td>
<td style="text-align: left;">GRAY+alpha</td>
<td style="text-align: left;">8</td>
<td style="text-align: left;">16</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ga16, ag16</td>
<td style="text-align: left;">ga16</td>
<td style="text-align: left;">GRAY+alpha</td>
<td style="text-align: left;">16</td>
<td style="text-align: left;">32</td>
</tr>
<tr class="even">
<td style="text-align: left;">g1</td>
<td style="text-align: left;">ga8</td>
<td style="text-align: left;">GRAY</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">g2</td>
<td style="text-align: left;">ga8</td>
<td style="text-align: left;">GRAY</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">2</td>
</tr>
<tr class="even">
<td style="text-align: left;">g4</td>
<td style="text-align: left;">ga8</td>
<td style="text-align: left;">GRAY</td>
<td style="text-align: left;">4</td>
<td style="text-align: left;">4</td>
</tr>
<tr class="odd">
<td style="text-align: left;">g8</td>
<td style="text-align: left;">ga8</td>
<td style="text-align: left;">GRAY</td>
<td style="text-align: left;">8</td>
<td style="text-align: left;">8</td>
</tr>
<tr class="even">
<td style="text-align: left;">g16</td>
<td style="text-align: left;">ga16</td>
<td style="text-align: left;">GRAY</td>
<td style="text-align: left;">16</td>
<td style="text-align: left;">16</td>
</tr>
<tr class="odd">
<td style="text-align: left;">cmyk8</td>
<td style="text-align: left;">cmyk8</td>
<td style="text-align: left;">inverse CMYK</td>
<td style="text-align: left;">8</td>
<td style="text-align: left;">32</td>
</tr>
<tr class="even">
<td style="text-align: left;">ycc8</td>
<td style="text-align: left;">ycc8</td>
<td style="text-align: left;">JPEG YCbCr 8</td>
<td style="text-align: left;">8</td>
<td style="text-align: left;">24</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ycck8</td>
<td style="text-align: left;">ycck8</td>
<td style="text-align: left;">JPEG YCbCrK 8</td>
<td style="text-align: left;">8</td>
<td style="text-align: left;">32</td>
</tr>
<tr class="even">
<td style="text-align: left;">rgbaf</td>
<td style="text-align: left;">rgbaf</td>
<td style="text-align: left;">RGB+alpha</td>
<td style="text-align: left;">32</td>
<td style="text-align: left;">128</td>
</tr>
<tr class="odd">
<td style="text-align: left;">rgbad</td>
<td style="text-align: left;">rgbaf</td>
<td style="text-align: left;">RGB+alpha</td>
<td style="text-align: left;">64</td>
<td style="text-align: left;">256</td>
</tr>
<tr class="even">
<td style="text-align: left;">raw8</td>
<td style="text-align: left;">raw8</td>
<td style="text-align: left;">X</td>
<td style="text-align: left;">8</td>
<td style="text-align: left;">8</td>
</tr>
<tr class="odd">
<td style="text-align: left;">raw16</td>
<td style="text-align: left;">raw16</td>
<td style="text-align: left;">X</td>
<td style="text-align: left;">16</td>
<td style="text-align: left;">16</td>
</tr>
<tr class="even">
<td style="text-align: left;">raw32</td>
<td style="text-align: left;">raw32</td>
<td style="text-align: left;">X</td>
<td style="text-align: left;">32</td>
<td style="text-align: left;">32</td>
</tr>
<tr class="odd">
<td style="text-align: left;">raw64</td>
<td style="text-align: left;">raw64</td>
<td style="text-align: left;">X</td>
<td style="text-align: left;">64</td>
<td style="text-align: left;">64</td>
</tr>
</tbody>
</table>
<p><strong>NOTE:</strong> For 16-bit RGB formats the color channels are stored in a little-endian unsigned integer, so rgb565 actually contains the blue and half of the green channel in its first byte.</p>
<h3 id="predefined-colortypes">Predefined colortypes</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>name</strong></th>
<th style="text-align: left;"><strong>channels</strong></th>
<th style="text-align: left;"><strong>value type</strong></th>
<th style="text-align: left;"><strong>value range</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">rgba8</td>
<td style="text-align: left;">r, g, b, a</td>
<td style="text-align: left;">integer</td>
<td style="text-align: left;">0..0xff</td>
</tr>
<tr class="even">
<td style="text-align: left;">rgba16</td>
<td style="text-align: left;">r, g, b, a</td>
<td style="text-align: left;">integer</td>
<td style="text-align: left;">0..0xffff</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ga8</td>
<td style="text-align: left;">g, a</td>
<td style="text-align: left;">integer</td>
<td style="text-align: left;">0..0xff</td>
</tr>
<tr class="even">
<td style="text-align: left;">ga16</td>
<td style="text-align: left;">g, a</td>
<td style="text-align: left;">integer</td>
<td style="text-align: left;">0..0xffff</td>
</tr>
<tr class="odd">
<td style="text-align: left;">cmyk8</td>
<td style="text-align: left;">c, m, y, k</td>
<td style="text-align: left;">integer</td>
<td style="text-align: left;">0..0xff</td>
</tr>
<tr class="even">
<td style="text-align: left;">ycc8</td>
<td style="text-align: left;">y, c, c</td>
<td style="text-align: left;">integer</td>
<td style="text-align: left;">0..0xff</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ycck8</td>
<td style="text-align: left;">y, c, c, k</td>
<td style="text-align: left;">integer</td>
<td style="text-align: left;">0..0xff</td>
</tr>
<tr class="even">
<td style="text-align: left;">rgbaf</td>
<td style="text-align: left;">r, g, b, a</td>
<td style="text-align: left;">float or double</td>
<td style="text-align: left;">0..1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">raw8</td>
<td style="text-align: left;">x</td>
<td style="text-align: left;">integer</td>
<td style="text-align: left;">0..0xff</td>
</tr>
<tr class="even">
<td style="text-align: left;">raw16</td>
<td style="text-align: left;">x</td>
<td style="text-align: left;">integer</td>
<td style="text-align: left;">0..0xffff</td>
</tr>
<tr class="odd">
<td style="text-align: left;">raw32</td>
<td style="text-align: left;">x</td>
<td style="text-align: left;">integer</td>
<td style="text-align: left;">0..0xffffffff</td>
</tr>
<tr class="even">
<td style="text-align: left;">raw64</td>
<td style="text-align: left;">x</td>
<td style="text-align: left;">integer</td>
<td style="text-align: left;">0..0xffffffffffffffffUL</td>
</tr>
</tbody>
</table>
<h2 id="quick-api-reference">Quick API Reference</h2>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>bitmap info</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>bitmap.format(bmp|format_name) -&gt; format</code>,</td>
<td>bitmap format (a table)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>bitmap.stride(bmp) -&gt; stride</code></td>
<td>row stride in bytes</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>bitmap.row_size(bmp) -&gt; size</code></td>
<td>row size in bytes</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>bitmap.colortype(bmp|colortype_name) -&gt; colortype</code></td>
<td>bitmap colortype (a table)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>bitmap operations</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>bitmap.new(w, h, ...) -&gt; dst</code></td>
<td>create a bitmap</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>bitmap.copy(src[, format], ...) -&gt; dst</code></td>
<td>copy and convert a bitmap</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>bitmap.paint(dst, src, dstx, dsty, ...) -&gt; dst</code></td>
<td>paint a bitmap on another</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>bitmap.clear([byte_value])</code></td>
<td>clear bitmap</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>bitmap.sub(src, [x], [y], [w], [h]) -&gt; dst</code></td>
<td>make a sub-bitmap</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>pixel access</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>bitmap.pixel_interface(src) -&gt; getpixel, setpixel</code></td>
<td>get a pixel interface</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>bitmap.channel_interface(bmp, n) -&gt; getval, setval</code></td>
<td>get a channel interface</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>dithering</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>bitmap.dither.fs(bmp, rN, gN, bN, aN)</code></td>
<td>apply dithering</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>bitmap.dither.ordered(bmp, rN, gN, bN, aN)</code></td>
<td>apply dithering</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>effects</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>bitmap.invert(bmp)</code></td>
<td>invert colors (in place)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>bitmap.grayscale(bmp)</code></td>
<td>desaturate (in place)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>bitmap.convolve(src, kernel, [edge]) -&gt; dst</code></td>
<td>convolve</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>bitmap.sharpen(src[, threshold]) -&gt; dst</code></td>
<td>sharpen</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>bitmap.mirror(src)</code></td>
<td>mirror horizontally (in place)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>alpha blending</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>bitmap.blend(src, dst, [operator], [x], [y])</code></td>
<td>blend source into dest bitmap</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>resizing</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>bitmap.resize.nearest|bilinear(src, w, h) -&gt; dst</code></td>
<td>resize to new</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>bitmap.resize.nearest|bilinear(src, dst) -&gt; dst</code></td>
<td>resize to dest</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>utilities</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>bitmap.min_stride(format, width) -&gt; min_stride</code></td>
<td>minimum stride for width</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>bitmap.aligned_stride(stride[, align]) -&gt; stride, align</code></td>
<td>next aligned stride</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>bitmap.aligned_pointer(ptr[, align]) -&gt; ptr, align</code></td>
<td>next aligned pointer</td>
</tr>
</tbody>
</table>
<h2 id="bitmap-operations">Bitmap operations</h2>
<h3 id="bitmap.neww-h-format-bottom_up-align-stride-alloc---new_bmp"><code>bitmap.new(w, h, format, [bottom_up], [align], [stride], [alloc]) -&gt; new_bmp</code></h3>
<p>Create a bitmap object. The optional <code>align</code> (which defaults to 1) specifies the data pointer and stride alignment (<code>true</code> means 4). The optional <code>alloc</code> is an <code>alloc(bytes) -&gt; data</code> function (eg. <a href="/glue">glue</a>.malloc).</p>
<h3 id="bitmap.copybmp-format-bottom_up-align-stride---new_bmp"><code>bitmap.copy(bmp, [format], [bottom_up], [align], [stride]) -&gt; new_bmp</code></h3>
<p>Copy a bitmap, optionally to a new format, orientation and stride. If <code>format</code> is not specified, stride and orientation default to those of source bitmap’s, otherwise they default to top-down, minimum stride.</p>
<h3 id="bitmap.paintdest_bmp-source_bmp-dstx-dsty-convert_pixel-src_colortype-dst_colortype---dest_bmp"><code>bitmap.paint(dest_bmp, source_bmp[, dstx, dsty][, convert_pixel, [src_colortype], [dst_colortype]]) -&gt; dest_bmp</code></h3>
<p>Paint a source bitmap into a destination bitmap, with all the necessary clipping and pixel and colortype conversions.</p>
<p>The optional <code>convert_pixel</code> is a pixel conversion function to be called for each pixel as <code>convert_pixel(a, b, c, ...) -&gt; x, y, z, ...</code>. It receives the channel values of the source bitmap in its original colortype (or in <code>src_colortype</code>, if given) and must return the converted channel values for the destination bitmap in its colortype (or in <code>dst_colortype</code>, if that is given).</p>
<p>In some cases, the destination bitmap is allowed to have the same data buffer as the source bitmap. Specifically, it must have the same orientation, smaller or equal stride and smaller or equal pixel size. The destination bitmap can also be the source bitmap itself, which is useful for performing custom transformations via the <code>convert_pixel</code> callback.</p>
<h3 id="bitmap.subbmp-x-y-w-h---sub_bmp"><code>bitmap.sub(bmp, [x], [y], [w], [h]) -&gt; sub_bmp</code></h3>
<p>Crop a bitmap without copying the pixels (the <code>data</code> field of the sub-bitmap is a pointer into the <code>data</code> buffer of the parent bitmap). The parent bitmap is pinned in the <code>parent</code> field of the sub-bitmap to prevent garbage collection of the data buffer. Other than that, the sub-bitmap behaves exactly like a normal bitmap (it can be further sub’ed for instance). The coordinates default to <code>0, 0, bmp.w, bmp.h</code> respectively. The coordinates are adjusted to fit the parent bitmap. If they result in zero width or height, nothing is returned.</p>
<p>To get real cropping, just copy the bitmap, specifying the format and orientation to reset the stride:</p>
<pre><code>sub = bitmap.copy(sub, sub.format, sub.bottom_up)</code></pre>
<blockquote>
<p>NOTE: For 1, 2, 4 bpp formats, the coordinates must be such that the data pointer points to the beginning of a byte (that is, is not fractional). For a non-fractional stride, this means the <code>x</code> coordinate must be a multiple of 8, 4, 2 respectively. For fractional strides don’t even bother.</p>
</blockquote>
<h2 id="pixel-interface">Pixel interface</h2>
<h3 id="bitmap.pixel_interfacebitmap-colortype---getpixel-setpixel"><code>bitmap.pixel_interface(bitmap[, colortype]) -&gt; getpixel, setpixel</code></h3>
<p>Return an API for getting and setting individual pixels of a bitmap object:</p>
<ul>
<li><code>getpixel(x, y) -&gt; a, b, c, ...</code></li>
<li><code>setpixel(x, y, a, b, c, ...)</code></li>
</ul>
<p>where a, b, c are the individual color channels, converted to the specified colortype or in the colortype of the bitmap (i.e. r, g, b, a for the ‘rgba’ colortype, etc.).</p>
<h4 id="example">Example:</h4>
<div class="sourceCode" id="cb2"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">local</span> <span class="kw">function</span> darken<span class="op">(</span>r<span class="op">,</span> g<span class="op">,</span> b<span class="op">,</span> a<span class="op">)</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>   <span class="cf">return</span> r <span class="op">/</span> <span class="dv">2</span><span class="op">,</span> g <span class="op">/</span> <span class="dv">2</span><span class="op">,</span> b <span class="op">/</span> <span class="dv">2</span><span class="op">,</span> a <span class="co">--make 2x darker</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="cf">end</span></span>
<span id="cb2-4"><a href="#cb2-4"></a></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="kw">local</span> getpixel<span class="op">,</span> setpixel <span class="op">=</span> bitmap<span class="op">.</span>pixel_interface<span class="op">(</span>bmp<span class="op">)</span></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="cf">for</span> y <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> bmp<span class="op">.</span>h<span class="op">-</span><span class="dv">1</span> <span class="cf">do</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>   <span class="cf">for</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> bmp<span class="op">.</span>w<span class="op">-</span><span class="dv">1</span> <span class="cf">do</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>      setpixel<span class="op">(</span>x<span class="op">,</span> y<span class="op">,</span> darken<span class="op">(</span>getpixel<span class="op">(</span>x<span class="op">,</span> y<span class="op">)))</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>   <span class="cf">end</span></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="cf">end</span></span>
<span id="cb2-11"><a href="#cb2-11"></a></span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="co">--the above has the same effect as:</span></span>
<span id="cb2-13"><a href="#cb2-13"></a>bitmap<span class="op">.</span>paint<span class="op">(</span>bmp<span class="op">,</span> bmp<span class="op">,</span> darken<span class="op">)</span></span></code></pre></div>
<h2 id="channel-interface">Channel interface</h2>
<h3 id="bitmap.channel_interfacebitmap-channel---getvalue-setvalue"><code>bitmap.channel_interface(bitmap, channel) -&gt; getvalue, setvalue</code></h3>
<p>Return an API for getting and setting values for a single color channel:</p>
<ul>
<li><code>getvalue(x, y) -&gt; v</code></li>
<li><code>setvalue(x, y, v)</code></li>
</ul>
<h2 id="dithering">Dithering</h2>
<h3 id="bitmap.dither.fsbmp-rbits-gbits-bbits-abits"><code>bitmap.dither.fs(bmp, rbits, gbits, bbits, abits)</code></h3>
<p>Dither a bitmap using the <a href="http://en.wikipedia.org/wiki/Floyd%E2%80%93Steinberg_dithering">Floyd-Steinberg dithering</a> algorithm. <code>*bits</code> specify the number of bits of color to keep for each channel (eg. <code>bitmap.dither.fs(bmp, 5, 6, 5, 0)</code> dithers a bitmap so that its colors fit into the <code>rgb565</code> format). Only implemented for 4-channel colortypes.</p>
<h3 id="bitmap.dither.orderedbmp-mapsize"><code>bitmap.dither.ordered(bmp, mapsize)</code></h3>
<p>Dither a bitmap using the <a href="http://en.wikipedia.org/wiki/Ordered_dithering">ordered dithering</a> algorithm. <code>mapsize</code> specifies the threshold map to use and can be 2, 3, 4 or 8. Use the demo to see how this parameter affects the output quality depending on the output format (it’s not a clear-cut choice). Implemented for 2-channel and 4-channel colortypes. Note that actual clipping of the low bits is not done, it will be done naturally when converting the bitmap to a lower bit depth.</p>
<h2 id="pixel-effects">Pixel effects</h2>
<h3 id="bitmap.invertbmp"><code>bitmap.invert(bmp)</code></h3>
<p>Invert colors.</p>
<h3 id="bitmap.grayscalebmp"><code>bitmap.grayscale(bmp)</code></h3>
<p>Convert pixels to grayscale, without changing the format.</p>
<h3 id="bitmap.convolvebmp-kernel-edge---new_bmp"><code>bitmap.convolve(bmp, kernel, [edge]) -&gt; new_bmp</code></h3>
<p>Convolve a bitmap using a kernel matrix (a Lua array of arrays of the same length). <code>edge</code> can be <code>crop</code>, <code>wrap</code> or <code>extend</code> (default is <code>extend</code>).</p>
<h3 id="bitmap.sharpenbmp-threshold---new_bmp"><code>bitmap.sharpen(bmp[, threshold]) -&gt; new_bmp</code></h3>
<p>Sharpen a bitmap.</p>
<h2 id="alpha-blending">Alpha Blending</h2>
<h3 id="bitmap.blendsource_bmp-dest_bmp-operator-x-y"><code>bitmap.blend(source_bmp, dest_bmp, [operator], [x], [y])</code></h3>
<p>Blend <code>source_bmp</code> into <code>dest_bmp</code> using a blending operator at <code>x,y</code> coordinates in the target bitmap (default is <code>0,0</code>). Operators are in the <code>bitmap.blend_op</code> table for inspection.</p>
<h2 id="resizing">Resizing</h2>
<h3 id="bitmap.resize.nearestbilinearbmp-w-h---new_bmp-bitmap.resize.nearestbilinearsource_bmp-dest_bmp---dest_bmp"><code>bitmap.resize.nearest|bilinear(bmp, w, h) -&gt; new_bmp</code> <br> <code>bitmap.resize.nearest|bilinear(source_bmp, dest_bmp) -&gt; dest_bmp</code></h3>
<p>Resize a bitmap.</p>
<h2 id="utilities">Utilities</h2>
<h3 id="bitmap.min_strideformat-width---min_stride"><code>bitmap.min_stride(format, width) -&gt; min_stride</code></h3>
<p>Return the minimum stride in bytes given a format and width. A bitmap data buffer should never be smaller than <code>min_stride * height</code>.</p>
<h3 id="bitmap.aligned_stridestride-align---stride-align"><code>bitmap.aligned_stride(stride[, align]) -&gt; stride, align</code></h3>
<p>Given a stride (which can also be fractional) and a power-of-two alignment, return the next smallest stride that is a multiple of the alignment (<code>align</code> defaults to 1 and <code>true</code> means 4).</p>
<h3 id="bitmap.aligned_pointerptr-align---ptr-align"><code>bitmap.aligned_pointer(ptr[, align]) -&gt; ptr, align</code></h3>
<p>Same as <code>aligned_stride()</code> but for pointers. The returned pointer is of type <code>void*</code>.</p>
<h3 id="bitmap.row_sizebmp---size"><code>bitmap.row_size(bmp) -&gt; size</code></h3>
<p>Bitmap’s row size, in bytes, i.e. bitmap’s minimum stride.</p>
<h2 id="introspection">Introspection</h2>
<h3 id="bitmap.conversionssource_format---iter---name-def"><code>bitmap.conversions(source_format) -&gt; iter() -&gt; name, def</code></h3>
<p>Given a source bitmap format, iterate through all the formats that the source format can be converted to. <code>name</code> is the format name and <code>def</code> is the format definition which is a table with the fields <code>bpp</code>, <code>ctype</code>, <code>colortype</code>, <code>read</code>, <code>write</code>.</p>
<h3 id="bitmap.dumpinfo"><code>bitmap.dumpinfo()</code></h3>
<p>Print the list of supported pixel formats and the list of supported colortype conversions.</p>
<h2 id="extending">Extending</h2>
<p>Extending the <code>bitmap</code> module with new colortypes, formats, conversions and module functions is easy. Look at the <code>bitmap_rgbaf</code> sub-module for an example on how to do that. For the submodule to be loaded automatically you need to reference it in the <code>bitmap</code> module too in a few key spots. Again, look at how <code>rgbaf</code> does it.</p>
<h3 id="custom-formats">Custom formats</h3>
<p>A custom pixel format definition is a table with the following fields:</p>
<ul>
<li><code>bpp</code> - pixel size, in bits (must be an even number of bits).</li>
<li><code>ctype</code> - C type to cast <code>data</code> to when reading and writing pixels (see below).</li>
<li><code>colortype</code> - a string naming a standard color type or a table specifying a custom color type. The channel values that <code>read</code> and <code>write</code> refer to depend on the colortype, eg. for the ‘rgba8’ colortype, the read function must return 4 numbers in the 0-255 range corresponding to the R, G, B, A channels.</li>
<li><code>read</code> - a function to be called as <code>read(data, i) -&gt; a, b, c, ...</code>; the function must decode the pixel at <code>data[i]</code> and return its channel values according to colortype.</li>
<li><code>write</code> - a function to be called as <code>write(data, i, a, b, c, ...)</code>; the function must encode the given channel values according to colortype and write the pixel at <code>data[i]</code>.
<ul>
<li>for formats that have bpp &lt; 8, the index i is fractional and the bit offset of the pixel is at <code>bit.band(i * 8, 7)</code>.</li>
</ul></li>
</ul>
<h3 id="custom-colortypes">Custom colortypes</h3>
<p>A custom colortype definition is a table with the following fields:</p>
<ul>
<li><code>channels</code> - a string with each letter a channel name, eg. ‘rgba’, so that <code>#channels</code> indicates the number of channels.</li>
<li><code>max</code> - maximum value to which the channel values need to be clipped.</li>
<li><code>bpc</code> - bits/channel - same meaning as <code>max</code> but in bits.</li>
</ul>
<h2 id="todo">TODO</h2>
<ul>
<li>premuliply / unpremultiply alpha</li>
</ul>
