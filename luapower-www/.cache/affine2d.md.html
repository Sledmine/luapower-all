<h2 id="local-matrix-requireaffine2d"><code>local matrix = require'affine2d'</code></h2>
<h2 id="api">API</h2>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>matrix(xx, yx, xy, yy, x0, y0) -&gt; mt</code></td>
<td style="text-align: left;">Create a new matrix.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>matrix() -&gt; mt</code></td>
<td style="text-align: left;">Create a new matrix with identity (<code>1, 0, 0, 1, 0, 0</code>).</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>mt:set(xx, yx, xy, yy, x0, y0) -&gt; mt</code></td>
<td style="text-align: left;">Set the matrix fields.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>mt:reset() -&gt; mt</code></td>
<td style="text-align: left;">Set the matrix to identity (<code>1, 0, 0, 1, 0, 0</code>).</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>mt:unpack() -&gt; xx, yx, xy, yy, x0, y0</code></td>
<td style="text-align: left;">Unpack the matrix fields.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>mt:copy() -&gt; newmt</code></td>
<td style="text-align: left;">Create a new matrix with the same fields as <code>mt</code>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>mt:transform_point(x, y) -&gt; tx, ty</code><br />
<code>mt(x, y) -&gt; tx, ty</code></td>
<td style="text-align: left;">Transform a 2D point.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>mt:transform_distance(x, y) -&gt; dx, dy</code></td>
<td style="text-align: left;">Transform a point ignoring translation.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>mt:multiply(bxx, byx, bxy, byy, bx0, by0) -&gt; mt</code></td>
<td style="text-align: left;">Multiply <code>mt * b</code> and store the result in <code>mt</code>.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>mt:transform(bxx, byx, bxy, byy, bx0, by0) -&gt; mt</code></td>
<td style="text-align: left;">Multiply <code>b * mt</code> and store the result in <code>mt</code>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>mt:determinant() -&gt; det</code></td>
<td style="text-align: left;">Compute the matrix determinant.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>mt:is_invertible() -&gt; true | false</code></td>
<td style="text-align: left;">Check if the matrix is invertible, that is, if the determinant is not 0, 1/0 or -1/0.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>mt:scalar_multilpy(s) -&gt; mt</code></td>
<td style="text-align: left;">Mulitply each field of the matrix with a scalar value.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>mt:inverse() -&gt; newmt</code></td>
<td style="text-align: left;">Return the inverse matrix, or nothing if the matrix is not invertible.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>mt:translate(x, y) -&gt; mt</code></td>
<td style="text-align: left;">Translate the matrix.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>mt:scale(sx, sy) -&gt; mt</code><br />
<code>mt:scale(s)</code></td>
<td style="text-align: left;">Scale the matrix.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>mt:scale_around(cx, cy, sx, sy) -&gt; mt</code><br />
<code>mt:scale_around(cx, cy, s) -&gt; mt</code></td>
<td style="text-align: left;">Scale the matrix around a point.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>mt:rotate(angle) -&gt; mt</code></td>
<td style="text-align: left;">Rotate the matrix. The angle is in radians.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>mt:rotate_around(cx, cy, angle) -&gt; mt</code></td>
<td style="text-align: left;">Rotate the matrix around a point. The angle is in radians.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>mt:skew(angle_x, angle_y) -&gt; mt</code></td>
<td style="text-align: left;">Skew the matrix. Angles are in radians.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>mt:is_identity() -&gt; true | false</code></td>
<td style="text-align: left;">Check if the matrix is the identity matrix, thus having no effect on the input.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>mt:has_unity_scale() -&gt; true | false</code></td>
<td style="text-align: left;">Check that no scaling is done with this transform, only flipping and multiple-of-90-degree rotation.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>mt:has_uniform_scale() -&gt; true | false</code></td>
<td style="text-align: left;">Check that scaling with this transform is uniform on both axes.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>mt:scale_factor() -&gt; s</code></td>
<td style="text-align: left;">Largest dimension of the bounding box of the transformed unit square.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>mt:is_pixel_exact() -&gt; true | false</code></td>
<td style="text-align: left;">Check that pixels map 1:1 with this transform so that no filtering is necessary to project an image to the screen for example.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>mt:is_straight() -&gt; true | false</code></td>
<td style="text-align: left;">Check that there’s no skew and that there’s no rotation other than multiple-of-90-degree rotation.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>mt1 * mt2 -&gt; newmt</code></td>
<td style="text-align: left;">Multiply two matrices and return the result as a new matrix.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>mt1 == mt2</code></td>
<td style="text-align: left;">Equality test (check if all fields are equal).</td>
</tr>
</tbody>
</table>
