<h2 id="local-oo-requireoo"><code>local oo = require'oo'</code></h2>
<p>Object system with virtual properties and method overriding hooks.</p>
<h2 id="in-a-nutshell">In a nutshell</h2>
<ul>
<li>single, dynamic inheritance by default:
<ul>
<li><code>Fruit = oo.Fruit()</code></li>
<li><code>Apple = oo.Apple(Fruit, {carpels = 5})</code></li>
<li><code>Apple.carpels -&gt; 5</code> (class field)</li>
<li><code>apple = Apple(...)</code></li>
<li><code>apple.carpels -&gt; 5</code> (serves as default value)</li>
<li><code>apple.super -&gt; Apple</code></li>
<li><code>Apple.super -&gt; Fruit</code></li>
<li><code>apple.isApple, apple.isFruit, Apple.isApple, Apple.isFruit -&gt; true</code></li>
</ul></li>
<li>multiple, static inheritance by request:
<ul>
<li><code>Apple:inherit(Fruit[,replace])</code> - statically inherit <code>Fruit</code>, optionally replacing existing properties.</li>
<li><code>Apple:detach()</code> - detach from the parent class, in other words statically inherit <code>self.super</code>.</li>
</ul></li>
<li>virtual properties with getter and setter:
<ul>
<li>reading <code>apple.foo</code> calls <code>Apple:get_foo()</code> to get the value, if <code>apple.get_foo</code> is defined.</li>
<li>assignment to <code>apple.foo</code> calls <code>Apple:set_foo(value)</code> if <code>Apple.set_foo</code> is defined.</li>
<li>missing the setter, the property is considered read-only and the assignment fails.</li>
</ul></li>
<li>method overriding hooks:
<ul>
<li><code>function Apple:before_pick(args...) end</code> makes <code>apple:pick()</code> call the code inside <code>before_pick()</code> first.</li>
<li><code>function Apple:after_pick(args...) end</code> makes <code>apple:pick()</code> call the code inside <code>after_pick()</code> last.</li>
<li><code>function Apple:override_pick(inherited, ...) end</code> lets you override <code>Apple:pick()</code> and call <code>inherited(self, ...)</code>.</li>
</ul></li>
<li>virtual classes (aka dependency injection, described below).</li>
<li>introspection:
<ul>
<li><code>oo.is(obj|class, class|classname) -&gt; true|false</code> - check instance/class ancestry</li>
<li><code>oo.isinstance(obj|class[, class|classname]) -&gt; true|false</code> - check instance ancestry</li>
<li><code>apple:is(class|classname) -&gt; true|false</code> - check instance/class ancestry</li>
<li><code>apple:isinstance([class|classname]) -&gt; true|false</code> - check instance ancestry</li>
<li><code>oo.closest_ancestor(apple, orange) -&gt; Fruit</code> - closest ancestor of <code>orange</code> in <code>apple</code>’s hierarchy</li>
<li>`apple:hasproperty(name) -&gt; false | true, ‘field’|‘property’ - check if property exists without accessing its value</li>
<li><code>self:allpairs([super]) -&gt; iterator() -&gt; name, value, source</code> - iterate all properties, including inherited <em>and overriden</em> ones up until <code>super</code>.</li>
<li><code>self:allproperties([super])</code> -&gt; get a table of all current properties and values, including inherited ones up until <code>super</code>.</li>
<li><code>self:inspect([show_oo_fields])</code> - inspect the class/instance structure and contents in detail (requires <a href="/glue">glue</a>).</li>
</ul></li>
<li>overridable subclassing and instantiation mechanisms:
<ul>
<li><code>Fruit = oo.Fruit()</code> is sugar for <code>Fruit = oo.Object:subclass('Fruit')</code></li>
<li><code>Apple = oo.Apple(Fruit)</code> is sugar for <code>Apple = Fruit:subclass('Apple')</code></li>
<li><code>apple = Apple(...)</code> is sugar for <code>apple = Apple:create(...)</code>
<ul>
<li><code>Apple:create()</code> calls <code>apple:init(...)</code></li>
</ul></li>
</ul></li>
</ul>
<h2 id="inheritance-and-instantiation">Inheritance and instantiation</h2>
<p><strong>Classes are created</strong> with <code>oo.ClassName([super])</code>, where <code>super</code> is usually another class, but can also be an instance, which is useful for creating polymorphic “views” on existing instances.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">local</span> Fruit <span class="op">=</span> oo<span class="op">.</span>Fruit<span class="op">()</span></span></code></pre></div>
<p>You can also create anonymous classes with <code>oo.class([super])</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">local</span> cls <span class="op">=</span> oo<span class="op">.</span>class<span class="op">()</span></span></code></pre></div>
<p><strong>Instances are created</strong> with <code>cls:create(...)</code> or simply <code>cls()</code>, which in turn calls <code>cls:init(...)</code> which is the object constructor. While <code>cls</code> is normally a class, it can also be an instance, which effectively enables prototype-based inheritance.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">local</span> obj <span class="op">=</span> cls<span class="op">()</span></span></code></pre></div>
<p><strong>The superclass</strong> of a class or the class of an instance is accessible as <code>self.super</code>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb4-1"><a href="#cb4-1"></a><span class="fu">assert</span><span class="op">(</span>obj<span class="op">.</span>super <span class="op">==</span> cls<span class="op">)</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="fu">assert</span><span class="op">(</span>cls<span class="op">.</span>super <span class="op">==</span> oo<span class="op">.</span>Object<span class="op">)</span></span></code></pre></div>
<p><strong>Inheritance is dynamic</strong>: properties are looked up at runtime in <code>self.super</code> and changing a property or method in the superclass reflects on all subclasses and instances. This can be slow, but it saves space.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb5-1"><a href="#cb5-1"></a>cls<span class="op">.</span>the_answer <span class="op">=</span> <span class="dv">42</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="fu">assert</span><span class="op">(</span>obj<span class="op">.</span>the_answer <span class="op">==</span> <span class="dv">42</span><span class="op">)</span></span></code></pre></div>
<p><strong>You can detach</strong> the class/instance from its parent class by calling <code>self:detach() -&gt; self</code>. This copies all inherited fields to the class/instance and removes <code>self.super</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb6-1"><a href="#cb6-1"></a>cls<span class="op">:</span>detach<span class="op">()</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>obj<span class="op">:</span>detach<span class="op">()</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="fu">assert</span><span class="op">(</span>obj<span class="op">.</span>super <span class="op">==</span> <span class="kw">nil</span><span class="op">)</span></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="fu">assert</span><span class="op">(</span>cls<span class="op">.</span>super <span class="op">==</span> <span class="kw">nil</span><span class="op">)</span></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="fu">assert</span><span class="op">(</span>cls<span class="op">.</span>the_answer <span class="op">==</span> <span class="dv">42</span><span class="op">)</span></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="fu">assert</span><span class="op">(</span>obj<span class="op">.</span>the_answer <span class="op">==</span> <span class="dv">42</span><span class="op">)</span></span></code></pre></div>
<p><strong>Static inheritance</strong> can be achieved by calling <code>self:inherit([other],[replace],[stop_super]) -&gt; self</code> which copies over the properties of another class or instance, effectively <em>monkey-patching</em> <code>self</code>, optionally overriding properties with the same name. The fields <code>self.classname</code> and <code>self.super</code> are always preserved though, even with the <code>override</code> flag.</p>
<ul>
<li><code>other</code> can also be a plain table, in which case it is shallow-copied.</li>
<li><code>other</code> defaults to <code>self.super</code>.</li>
<li><code>stop_super</code> limits how far up in the inheritance chain of <code>other</code> too look for fields and properties to copy.</li>
<li>if <code>other</code> is not in <code>self</code>’s hierarchy, <code>stop_super</code> defaults to <code>oo.closest_ancestor(self, other)</code> in order to prevent inheriting any fields from common ancestors, which would undo any overridings done in subclasses of the closest ancestor.</li>
</ul>
<div class="sourceCode" id="cb7"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">local</span> other_cls <span class="op">=</span> oo<span class="op">.</span>class<span class="op">()</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>other_cls<span class="op">.</span>the_answer <span class="op">=</span> <span class="dv">13</span></span>
<span id="cb7-3"><a href="#cb7-3"></a></span>
<span id="cb7-4"><a href="#cb7-4"></a>obj<span class="op">:</span>inherit<span class="op">(</span>other_cls<span class="op">)</span></span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="fu">assert</span><span class="op">(</span>obj<span class="op">.</span>the_answer <span class="op">==</span> <span class="dv">13</span><span class="op">)</span> <span class="co">--obj continues to dynamically inherit cls.the_answer</span></span>
<span id="cb7-6"><a href="#cb7-6"></a>                             <span class="co">--but statically inherited other_cls.the_answer</span></span>
<span id="cb7-7"><a href="#cb7-7"></a></span>
<span id="cb7-8"><a href="#cb7-8"></a>obj<span class="op">.</span>the_answer <span class="op">=</span> <span class="kw">nil</span></span>
<span id="cb7-9"><a href="#cb7-9"></a><span class="fu">assert</span><span class="op">(</span>obj<span class="op">.</span>the_answer <span class="op">==</span> <span class="dv">42</span><span class="op">)</span> <span class="co">--reverted to class default</span></span>
<span id="cb7-10"><a href="#cb7-10"></a></span>
<span id="cb7-11"><a href="#cb7-11"></a>cls<span class="op">:</span>inherit<span class="op">(</span>other_cls<span class="op">)</span></span>
<span id="cb7-12"><a href="#cb7-12"></a><span class="fu">assert</span><span class="op">(</span>cls<span class="op">.</span>the_answer <span class="op">==</span> <span class="dv">42</span><span class="op">)</span> <span class="co">--no override</span></span>
<span id="cb7-13"><a href="#cb7-13"></a></span>
<span id="cb7-14"><a href="#cb7-14"></a>cls<span class="op">:</span>inherit<span class="op">(</span>other_cls<span class="op">,</span> <span class="kw">true</span><span class="op">)</span></span>
<span id="cb7-15"><a href="#cb7-15"></a><span class="fu">assert</span><span class="op">(</span>cls<span class="op">.</span>the_answer <span class="op">==</span> <span class="dv">13</span><span class="op">)</span> <span class="co">--override</span></span></code></pre></div>
<p>In fact, <code>self:detach()</code> is written as <code>self:inherit(self.super)</code> with the minor detail of setting <code>self.classname = self.classname</code> and removing <code>self.super</code>.</p>
<p><strong>NOTE:</strong> Detaching instances <em>or final classes</em> helps preventing LuaJIT from bailing out to the interpreter which can result in 100x performance drop. Even in interpreter mode, detaching instances can increase performance for method lookup by 10x (see benchmarks).</p>
<p>You can do this easily with:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb8-1"><a href="#cb8-1"></a><span class="co">--detach instances of (subclasses of) myclass from their class.</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="co">--patching myclass or its subclasses afterwards will not affect</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="co">--existing instances but it will affect new instnaces.</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="kw">function</span> myclass<span class="op">:</span>before_init<span class="op">()</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>   self<span class="op">:</span>detach<span class="op">()</span></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="cf">end</span></span>
<span id="cb8-7"><a href="#cb8-7"></a></span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="co">--detach all new subclasses of myclass. patching myclass or its</span></span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="co">--supers afterwards will have no effect on existing subclasses</span></span>
<span id="cb8-10"><a href="#cb8-10"></a><span class="co">--of myclass or its instances. patching final classes though</span></span>
<span id="cb8-11"><a href="#cb8-11"></a><span class="co">--will affect both new and existing instances.</span></span>
<span id="cb8-12"><a href="#cb8-12"></a><span class="kw">function</span> myclass<span class="op">:</span>override_subclass<span class="op">(</span>inherited<span class="op">,</span> <span class="op">...)</span></span>
<span id="cb8-13"><a href="#cb8-13"></a>   <span class="cf">return</span> inherited<span class="op">(</span>self<span class="op">,</span> <span class="op">...):</span>detach<span class="op">()</span></span>
<span id="cb8-14"><a href="#cb8-14"></a><span class="cf">end</span></span></code></pre></div>
<p><strong>NOTE:</strong> Static inheritance changes field lookup semantics in a subtle way: because field values no longer dynamically overshadow the values set in the superclasses, setting a statically inherited field to <code>nil</code> doesn’t expose back the value from the super class, instead the field remains <code>nil</code>.</p>
<p>To further customize how the values are copied over for static inheritance, override <code>self:properties()</code>.</p>
<h2 id="virtual-properties">Virtual properties</h2>
<p><strong>Virtual properties</strong> are created by defining a getter and a setter. Once you have defined <code>self:get_foo()</code> and <code>self:set_foo(value)</code> you can read and write to <code>self.foo</code> and the getter and setter will be called instead. The setter is optional. Assigning a value to a property that doesn’t have a setter results in an error.</p>
<p>Getters and setters are only called on instances. This allows setting default values for properties on the class as plain fields with the same name as the property, following that those defaults will be applied manually in the constructor with <code>self.foo = self.super.foo</code>.</p>
<p>There are no virtual properties for classes. Use singleton instances instead.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">function</span> cls<span class="op">:</span>get_answer_to_life<span class="op">()</span> <span class="cf">return</span> deep_thought<span class="op">:</span>get_answer<span class="op">()</span> <span class="cf">end</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="kw">function</span> cls<span class="op">:</span>set_answer_to_life<span class="op">(</span>v<span class="op">)</span> deep_thought<span class="op">:</span>set_answer<span class="op">(</span>v<span class="op">)</span> <span class="cf">end</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>obj <span class="op">=</span> cls<span class="op">()</span></span>
<span id="cb9-4"><a href="#cb9-4"></a>obj<span class="op">.</span>answer_to_life <span class="op">=</span> <span class="dv">42</span></span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="fu">assert</span><span class="op">(</span>obj<span class="op">.</span>answer_to_life <span class="op">==</span> <span class="dv">42</span><span class="op">)</span> <span class="co">--assuming deep_thought can store a number</span></span></code></pre></div>
<p>Virtual properties can be <em>generated in bulk</em> given a <em>multikey</em> getter and a <em>multikey</em> setter and a list of property names, by calling <code>self:gen_properties(names, [getter], [setter])</code>. The setter and getter must be methods of form:</p>
<ul>
<li><code>getter(self, k) -&gt; v</code></li>
<li><code>setter(self, k, v)</code></li>
</ul>
<h2 id="overriding-hooks">Overriding hooks</h2>
<p>Overriding hooks are sugar to make method overriding more easy and readable.</p>
<p>Instead of:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">function</span> Apple<span class="op">:</span>pick<span class="op">(</span>arg<span class="op">)</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>   <span class="fu">print</span><span class="op">(</span><span class="st">&#39;picking&#39;</span><span class="op">,</span> arg<span class="op">)</span></span>
<span id="cb10-3"><a href="#cb10-3"></a>   <span class="kw">local</span> ret <span class="op">=</span> Apple<span class="op">.</span>super<span class="op">.</span>pick<span class="op">(</span>self<span class="op">,</span> arg<span class="op">)</span></span>
<span id="cb10-4"><a href="#cb10-4"></a>   <span class="fu">print</span><span class="op">(</span><span class="st">&#39;picked&#39;</span><span class="op">,</span> ret<span class="op">)</span></span>
<span id="cb10-5"><a href="#cb10-5"></a>   <span class="cf">return</span> ret</span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="cf">end</span></span></code></pre></div>
<p>Write:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">function</span> Apple<span class="op">:</span>override_pick<span class="op">(</span>inherited<span class="op">,</span> arg<span class="op">,</span> <span class="op">...)</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>   <span class="fu">print</span><span class="op">(</span><span class="st">&#39;picking&#39;</span><span class="op">,</span> arg<span class="op">)</span></span>
<span id="cb11-3"><a href="#cb11-3"></a>   <span class="kw">local</span> ret <span class="op">=</span> inherited<span class="op">(</span>self<span class="op">,</span> arg<span class="op">,</span> <span class="op">...)</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>   <span class="fu">print</span><span class="op">(</span><span class="st">&#39;picked&#39;</span><span class="op">,</span> ret<span class="op">)</span></span>
<span id="cb11-5"><a href="#cb11-5"></a>   <span class="cf">return</span> ret</span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="cf">end</span></span></code></pre></div>
<p>Or even better:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">function</span> Apple<span class="op">:</span>before_pick<span class="op">(</span>arg<span class="op">)</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>   <span class="fu">print</span><span class="op">(</span><span class="st">&#39;picking&#39;</span><span class="op">,</span> arg<span class="op">)</span></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="cf">end</span></span>
<span id="cb12-4"><a href="#cb12-4"></a></span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="kw">function</span> Apple<span class="op">:</span>after_pick<span class="op">(</span>arg<span class="op">)</span></span>
<span id="cb12-6"><a href="#cb12-6"></a>   <span class="fu">print</span><span class="op">(</span><span class="st">&#39;picked&#39;</span><span class="op">,</span> arg<span class="op">)</span></span>
<span id="cb12-7"><a href="#cb12-7"></a>   <span class="cf">return</span> ret</span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="cf">end</span></span></code></pre></div>
<p>By defining <code>self:before_&lt;method&gt;(...)</code> a new implementation for <code>self.&lt;method&gt;</code> is created which calls the before hook and then calls the existing (inherited) implementation. Both calls receive all arguments.</p>
<p>By defining <code>self:after_&lt;method&gt;(...)</code> a new implementation for <code>self.&lt;method&gt;</code> is created which calls the existing (inherited) implementation, after which it calls the hook and returns whatever the hook returns. Both calls receive all arguments.</p>
<p>By defining <code>self:override_&lt;method&gt;(inherited, ...)</code> you can access <code>self.super.&lt;method&gt;</code> as <code>inherited</code>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">function</span> cls<span class="op">:</span>before_init<span class="op">(</span>foo<span class="op">,</span> bar<span class="op">)</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>  self<span class="op">.</span>foo <span class="op">=</span> foo <span class="kw">or</span> default_foo</span>
<span id="cb13-3"><a href="#cb13-3"></a>  self<span class="op">.</span>bar <span class="op">=</span> bar <span class="kw">or</span> default_bar</span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="cf">end</span></span>
<span id="cb13-5"><a href="#cb13-5"></a></span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="kw">function</span> cls<span class="op">:</span>after_init<span class="op">()</span></span>
<span id="cb13-7"><a href="#cb13-7"></a>  <span class="co">--allocate resources</span></span>
<span id="cb13-8"><a href="#cb13-8"></a><span class="cf">end</span></span>
<span id="cb13-9"><a href="#cb13-9"></a></span>
<span id="cb13-10"><a href="#cb13-10"></a><span class="kw">function</span> cls<span class="op">:</span>before_destroy<span class="op">()</span></span>
<span id="cb13-11"><a href="#cb13-11"></a>  <span class="co">--destroy resources</span></span>
<span id="cb13-12"><a href="#cb13-12"></a><span class="cf">end</span></span></code></pre></div>
<p>If you don’t know the name of the method you want to override until runtime, use <code>cls:before(name, func)</code>, <code>cls:after(name, func)</code> and <code>cls:override(name, func)</code> instead.</p>
<h2 id="virtual-classes-aka-dependency-injection">Virtual classes (aka dependency injection)</h2>
<p>Virtual classes provide an additional way to extend composite objects (objects which need to instantiate other objects) beyond inheritance which doesn’t by itself cover extending the classes of the sub-objects of the composite object. Virtual classes come for free in languages where classes are first-class entitites: all you have to do is to make the inner class a class field of the outer class and instantiate it with <code>self:inner_class()</code>. This simple indirection has many advantages:</p>
<ul>
<li>it allows subclassing the inner class in subclasses of the outer class by just overriding the <code>inner_class</code> field.</li>
<li>using <code>self:inner_class()</code> instead of <code>self.inner_class()</code> passes the outer object as the second arg to the constructor of the inner object (the first arg is the inner object) so that you can reference the outer object in the constructor, which is usually needed.</li>
<li>the<code>inner_class</code> field can be used as a method of the outer class so it can be made part of its public API without needing any additional wrapping, and it can also be overriden with a normal method in subclasses of the outer class (the overriding mechanism still works even if it’s not overriding a real method).</li>
</ul>
<h2 id="events">Events</h2>
<p>Events are useful for associating actions with callback functions. This can already be done more flexibly with plain methods and overriding, but events have the distinct ability to revert the overidding at runtime (with <code>obj:off()</code>). They also differ in the fact that returning a non-nil value from a callback short-circuits the call chain and the value is returned back to the user.</p>
<p>The events functionality can be enabled by adding the <a href="/events">events</a> mixin to oo’s base class (or to any other class):</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">local</span> events <span class="op">=</span> <span class="fu">require</span><span class="st">&#39;events&#39;</span></span>
<span id="cb14-2"><a href="#cb14-2"></a>oo<span class="op">.</span>Object<span class="op">:</span>inherit<span class="op">(</span>events<span class="op">)</span></span></code></pre></div>
<h2 id="performance-tips">Performance Tips</h2>
<p>Instance fields are accessed directly but methods and default values (class fields) go through a slower dynamic dispatch function (it’s the price you pay for virtual properties). Copying class fields to the instance by calling <code>self:inherit()</code> will short-circuit this lookup at the expense of more memory consumption. Fields with a <code>nil</code> value go through the same function too so providing a <code>false</code> default value to those fields will also speed up their lookup.</p>
