<h2 id="local-blake2-requireblake2"><code>local blake2 = require'blake2'</code></h2>
<p>A ffi binding of the <a href="https://blake2.net/">BLAKE2</a> fast cryptographic hash.</p>
<h2 id="api">API</h2>
<p>In the table below, <code>?</code> is either <code>s</code>, <code>b</code>, <code>sp</code> or <code>bp</code> for each variant of the BLAKE2 algorithm.</p>
<table>
<colgroup>
<col style="width: 57%" />
<col style="width: 42%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>blake2.blake2?(s, [size], [key], [#out]) -&gt; s</code><br />
<code>blake2.blake2?(cdata, size, [key]) -&gt; s</code></td>
<td>compute the hash of a string or a cdata buffer.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>blake2.blake2?_digest([key, [#out] | opt_t]) -&gt; digest</code><br />
</td>
<td>get an object/function that can consume multiple data chunks before returning the hash</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>digest[:update](s, [size])</code><br />
<code>digest[:update](cdata, size)</code></td>
<td>consume a data chunk</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>digest[:final]() -&gt; s</code> <code>digest:final_to_buffer(buf)</code> <code>digest:length() -&gt; n</code></td>
<td>finalize and get the hash finalize and write the hash to a buffer hash byte length</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>digest:reset()</code></td>
<td>prepare for another digestion</td>
</tr>
</tbody>
</table>
<p>The hash is returned raw in a Lua string. To get it as hex use <a href="/glue">glue</a>.tohex().</p>
<p>The optional <code>key</code> arg is for keyed hashing (up to 64 bytes for BLAKE2b, up to 32 bytes for BLAKE2s).</p>
<p>The optional <code>#out</code> arg is for reducing the length of the output hash.</p>
<p>The constructors <code>blake2s_digest</code> and <code>blake2b_digest</code> can take a table in place of the <code>key</code> arg in which more options can be specified:</p>
<ul>
<li><code>salt</code> (’’): salt for randomized hashing (up to 16 bytes for BLAKE2b, up to 8 bytes for BLAKE2s).</li>
<li><code>personal</code> (’’): personalization string (up to 16 bytes for BLAKE2b, up to 8 bytes for BLAKE2s).</li>
<li><code>fanout</code> (1): fanout (0 to 255, 0 if unlimited, 1 in sequential mode).</li>
<li><code>depth</code> (1): maximal depth of tree (1 to 255, 255 if unlimited, 1 in sequential mode).</li>
<li><code>leaf_length</code> (0): maximal byte length of leaf (0 to 2^32-1, 0 if unlimited or in sequential mode).</li>
<li><code>node_offset</code> (0): node offset (0 to 2^64-1 for BLAKE2b, 0 to 2^48-1 for BLAKE2s, 0 for the first, leftmost, leaf, or in sequential mode).</li>
<li><code>node_depth</code> (0): node depth (0 to 255, 0 for leaves, or in sequential mode).</li>
<li><code>inner_length</code> (0): inner digest length (0 to 64 for BLAKE2b, 0 to 32 for BLAKE2s, 0 in sequential mode).</li>
<li><code>key</code>: key string for keyed hashing (up to 64 bytes for BLAKE2b, up to 32 bytes for BLAKE2s).</li>
<li><code>hash_length</code>: optional, for reducing the length of the output hash.</li>
</ul>
<p><strong>NOTE:</strong> the <code>salt</code> and <code>personal</code> options are zero-padded so <code>'foo'</code> is the same value as <code>'foo\0'</code> or <code>'foo\0\0'</code> with them (not so with <code>key</code>).</p>
<p>See section 2.10 in <a href="https://blake2.net/blake2_20130129.pdf">BLAKE2 specification</a> for comprehensive review of tree hashing.</p>
