<h2 id="local-lp-requireluapower"><code>local lp = require'luapower'</code></h2>
<p>This module leverages the many conventions in luapower to extract and aggregate metadata about packages, modules and documentation and perform various consistency checks. It gives accurate information about dependencies between modules and packages because it actually loads the Lua modules and tracks all <code>require</code> and <code>ffi.load</code> calls, and then it integrates that information with the package information that it gets from git and <a href="/luapower-git">multigit</a>. The entire API is memoized so it can be abused without worrying about caching the results of the function calls.</p>
<p>Accompanying the library there’s a command-line interface and an RPC server which can be used to track module dependencies across multiple platforms, run automated tests, etc.</p>
<h2 id="module-usage">Module usage</h2>
<p>The module assumes that the luapower tree is the current directory. If that’s not the case, you have say where it is:</p>
<pre><code>lp.luapower_dir = &#39;/path/to/luapower</code></pre>
<p>It also assumes that the luapower tree was cloned (see <a href="/luapower-git">luapower-git</a>) rather than just downloaded.</p>
<p>The API can be categorized based on the different types of things it does:</p>
<ol type="1">
<li>getting info about packages and modules in the local luapower tree - this is the bulk of the API.</li>
<li>connecting to an RPC server and using the API remotely, in order to collect data from other platforms.</li>
<li>creating/updating a small database (<a href="/files/luapower/luapower_db.lua">luapower_db.lua</a>) containing dependency information collected from different platforms.</li>
</ol>
<p>So the bulk of the API contains stuff like, eg.:</p>
<pre><code>lp.installed_packages() -&gt; {package = true}      get installed packages
lp.modules(package) -&gt; {module = path}           get a package&#39;s modules</code></pre>
<p>The API well documented in luapower.lua, so check that out. A quick way to explore the capabilities of the library is to try out the command-line interface.</p>
<h2 id="using-dependency-info-from-other-platforms">Using dependency info from other platforms</h2>
<p>Luapower computes dependency info on-the-fly, but to get accurate dependency info for a specific platform, luapower has to actually run on that platform So dependency info for platform X must be acquired on platform X. But that knowledge can be transferred and used on any other platform. This can happen live via RPC, or by filling in a database file and moving it around. You can also combine the two methods, so that you can update the database file on one machine with information collected via RPC.</p>
<h4 id="starting-an-rpc-server">Starting an RPC server:</h4>
<pre><code>$ ./luajit luapower_rpc.lua [IP] [PORT]</code></pre>
<h4 id="connecting-to-an-rpc-server-manually">Connecting to an RPC server manually:</h4>
<pre><code>lp.connect([ip], [port]) -&gt; lp</code></pre>
<p>The result is a full luapower API with the additional functions <code>close()</code>, <code>restart()</code>, and <code>stop()</code> to control the connection and/or the server.</p>
<p>Each connection gets its own separate Lua state to do stuff in, so the remote cache is lost when the connection is closed.</p>
<h4 id="configuring-luapower-to-use-rpc-servers">Configuring luapower to use RPC servers:</h4>
<pre><code>lp.servers = {linux64 = &#39;10.1.1.1&#39;, ...}</code></pre>
<p>To use the luapower command line with RPC servers, change the servers table in luapower.lua directly.</p>
<h4 id="updating-the-dependency-database">Updating the dependency database:</h4>
<pre><code>lp.update_db([package], [platform])

./lp update-db [PACKAGE] [PLATFORM]</code></pre>
<p>Passing nil (i.e. ‘–all’ in the cmdline version) as package updates all the packages, same with the platform (so not passing any args updates the whole db).</p>
