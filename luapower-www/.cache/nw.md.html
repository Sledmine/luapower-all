<h2 id="local-nw-requirenw"><code>local nw = require'nw'</code></h2>
<p>Cross-platform library for accessing windows, graphics and input in a consistent manner across Windows, Linux and OS X. Supports transparent windows, bgra8 bitmaps everywhere, drawing via <a href="/cairo">cairo</a> and <a href="/opengl">opengl</a>, edge snapping, fullscreen mode, multiple displays, hi-dpi, key mappings, triple-click events, timers, cursors, native menus, notification icons, all text in utf8, and more.</p>
<h2 id="status">Status</h2>
<p>See <a href="https://github.com/luapower/nw/issues">issues</a> and <a href="https://github.com/luapower/nw/milestones">milestones</a>.</p>
<h2 id="backends">Backends</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">API</th>
<th style="text-align: left;">Library</th>
<th style="text-align: left;">Developed &amp; Tested On</th>
<th style="text-align: left;">Probably Runs On</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">WinAPI</td>
<td style="text-align: left;"><a href="/winapi">winapi</a></td>
<td style="text-align: left;">Windows 7 x64</td>
<td style="text-align: left;">Windows XP/2000</td>
</tr>
<tr class="even">
<td style="text-align: left;">Cocoa</td>
<td style="text-align: left;"><a href="/objc">objc</a></td>
<td style="text-align: left;">OSX 10.12</td>
<td style="text-align: left;">OSX 10.9</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Xlib</td>
<td style="text-align: left;"><a href="/xlib">xlib</a></td>
<td style="text-align: left;">Ubuntu/Unity 18.04 x64</td>
<td style="text-align: left;">Ubuntu/Unity 10.04</td>
</tr>
</tbody>
</table>
<h2 id="example">Example</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">local</span> nw <span class="op">=</span> <span class="fu">require</span><span class="st">&#39;nw&#39;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">local</span> app <span class="op">=</span> nw<span class="op">:</span>app<span class="op">()</span>        <span class="co">--get the app singleton</span></span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">local</span> win <span class="op">=</span> app<span class="op">:</span>window<span class="op">{</span>     <span class="co">--create a new window</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>   w <span class="op">=</span> <span class="dv">400</span><span class="op">,</span> h <span class="op">=</span> <span class="dv">200</span><span class="op">,</span>        <span class="co">--specify window&#39;s frame size</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>   title <span class="op">=</span> <span class="st">&#39;hello&#39;</span><span class="op">,</span>         <span class="co">--specify window&#39;s title</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>   visible <span class="op">=</span> <span class="kw">false</span><span class="op">,</span>         <span class="co">--don&#39;t show it yet</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="op">}</span></span>
<span id="cb1-10"><a href="#cb1-10"></a></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="kw">function</span> win<span class="op">:</span>click<span class="op">(</span>button<span class="op">,</span> count<span class="op">)</span> <span class="co">--this is one way to bind events</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>   <span class="cf">if</span> button <span class="op">==</span> <span class="st">&#39;left&#39;</span> <span class="kw">and</span> count <span class="op">==</span> <span class="dv">3</span> <span class="cf">then</span> <span class="co">--triple click</span></span>
<span id="cb1-13"><a href="#cb1-13"></a>      app<span class="op">:</span>quit<span class="op">()</span></span>
<span id="cb1-14"><a href="#cb1-14"></a>   <span class="cf">end</span></span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="cf">end</span></span>
<span id="cb1-16"><a href="#cb1-16"></a></span>
<span id="cb1-17"><a href="#cb1-17"></a><span class="co">--this is another way to bind events which allows setting multiple</span></span>
<span id="cb1-18"><a href="#cb1-18"></a><span class="co">--handlers for the same event type.</span></span>
<span id="cb1-19"><a href="#cb1-19"></a>win<span class="op">:</span>on<span class="op">(</span><span class="st">&#39;keydown&#39;</span><span class="op">,</span> <span class="kw">function</span><span class="op">(</span>self<span class="op">,</span> key<span class="op">)</span></span>
<span id="cb1-20"><a href="#cb1-20"></a>   <span class="cf">if</span> key <span class="op">==</span> <span class="st">&#39;F11&#39;</span> <span class="cf">then</span></span>
<span id="cb1-21"><a href="#cb1-21"></a>      self<span class="op">:</span>fullscreen<span class="op">(</span><span class="kw">not</span> self<span class="op">:</span>fullscreen<span class="op">())</span> <span class="co">--toggle fullscreen state</span></span>
<span id="cb1-22"><a href="#cb1-22"></a>   <span class="cf">end</span></span>
<span id="cb1-23"><a href="#cb1-23"></a><span class="cf">end</span><span class="op">)</span></span>
<span id="cb1-24"><a href="#cb1-24"></a></span>
<span id="cb1-25"><a href="#cb1-25"></a><span class="kw">function</span> win<span class="op">:</span>repaint<span class="op">()</span>        <span class="co">--called when window needs repainting</span></span>
<span id="cb1-26"><a href="#cb1-26"></a>   <span class="kw">local</span> bmp <span class="op">=</span> win<span class="op">:</span>bitmap<span class="op">()</span>   <span class="co">--get the window&#39;s bitmap</span></span>
<span id="cb1-27"><a href="#cb1-27"></a>   <span class="kw">local</span> cr <span class="op">=</span> bmp<span class="op">:</span>cairo<span class="op">()</span>     <span class="co">--get a cairo drawing context</span></span>
<span id="cb1-28"><a href="#cb1-28"></a>   cr<span class="op">:</span>rgb<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">)</span>            <span class="co">--make it green</span></span>
<span id="cb1-29"><a href="#cb1-29"></a>   cr<span class="op">:</span>paint<span class="op">()</span></span>
<span id="cb1-30"><a href="#cb1-30"></a><span class="cf">end</span></span>
<span id="cb1-31"><a href="#cb1-31"></a></span>
<span id="cb1-32"><a href="#cb1-32"></a>win<span class="op">:</span>show<span class="op">()</span> <span class="co">--show it now that it was properly set up</span></span>
<span id="cb1-33"><a href="#cb1-33"></a></span>
<span id="cb1-34"><a href="#cb1-34"></a>app<span class="op">:</span>run<span class="op">()</span>  <span class="co">--start the event loop</span></span></code></pre></div>
<h2 id="api">API</h2>
<p><strong>NOTE:</strong> In the table below, <code>foo(t|f) /-&gt; t|f</code> is a shortcut for saying that <code>foo(t|f)</code> sets the value of foo and <code>foo() -&gt; t|f</code> gets it. <code>t|f</code> means <code>true|false</code>.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>the app object</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>nw:app() -&gt; app</code></td>
<td>the global application object</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>the app loop</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>app:run()</code></td>
<td>start the loop</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>app:stop()</code></td>
<td>stop the loop</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>app:running() -&gt; t|f</code></td>
<td>check if the loop is running</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>app:poll([timeout]) -&gt; t|f</code></td>
<td>process the next pending event (return true if there was one)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>app:maxfps(fps) -&gt; fps</code></td>
<td>cap the window repaint rate</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>quitting</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>app:quit()</code></td>
<td>quit the app, i.e.Â close all windows and stop the loop</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>app:autoquit(t|f) /-&gt; t|f</code></td>
<td>quit the app when the last visible window is closed (<code>true</code>)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>app:quitting() -&gt; [false]</code></td>
<td>event: quitting (return <code>false</code> to refuse)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:autoquit(t|f) /-&gt; t|f</code></td>
<td>quit the app when the window is closed (<code>false</code>)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>timers</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>app:runevery(seconds, func)</code></td>
<td>run a function on a timer (return <code>false</code> to stop it)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>app:runafter(seconds, func)</code></td>
<td>run a function on a timer once</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>app:run(func)</code></td>
<td>run a function on a zero-second timer once</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>app:sleep(seconds)</code></td>
<td>sleep without blocking an app:run() function</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>window tracking</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>app:windows(['#',][filter]) -&gt; {win1, ...}</code></td>
<td>all windows in creation order</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>app:window_created(win)</code></td>
<td>event: a window was created</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>app:window_closed(win)</code></td>
<td>event: a window was closed</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>window creation</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>app:window(t|cw,ch,[title],[vis]) -&gt; win</code></td>
<td>create a window</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>window closing</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:close([reason|force])</code></td>
<td>close the window and hide it or destroy it</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:free([force])</code></td>
<td>close the window and destroy it</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:hideonclose(t|f) /-&gt; t|f</code></td>
<td>hide on close or destroy on close</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:dead() -&gt; t|f</code></td>
<td>check if the window was destroyed</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:closing(reason, [closing_win])</code></td>
<td>event: closing (return <code>false</code> to refuse)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:closed()</code></td>
<td>event: window is about to be destroyed</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:closeable() -&gt; t|f</code></td>
<td>closeable flag</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>window &amp; app activation</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>app/win:active() -&gt; t|f</code></td>
<td>check if app/window is active</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>app:activate([mode])</code></td>
<td>activate the app</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>app:active_window() -&gt; win</code></td>
<td>the active window, if any</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:activate()</code></td>
<td>activate the window</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:activable() -&gt; t|f</code></td>
<td>activable flag</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>app/win:activated()</code></td>
<td>event: app/window was activated</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>app/win:deactivated()</code></td>
<td>event: app/window was deactivated</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>app instances</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>app:check_single_instance()</code></td>
<td>single app instance check</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>app.id</code></td>
<td>set an app ID</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>app:already_running() -&gt; t|f</code></td>
<td>check if other app instances running</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>app:wakeup_other_instances()</code></td>
<td>send wakeup event to other app instances</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>app:wakeup()</code></td>
<td>event: wakeup from another instance</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>app visibility (OSX)</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>app:visible(t|f) /-&gt; t|f</code></td>
<td>get/set app visibility</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>app:hide()</code></td>
<td>hide the app</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>app:unhide()</code></td>
<td>unhide the app</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>app:hidden()</code></td>
<td>event: app was hidden</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>app:unhidden()</code></td>
<td>event: app was unhidden</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>window state</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:visible(t|f) /-&gt; t|f</code></td>
<td>get/set window visibility</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:show()</code></td>
<td>show window (in its previous state)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:hide()</code></td>
<td>hide window</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:shown()</code></td>
<td>event: window was shown</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:hidden()</code></td>
<td>event: window was hidden</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:minimizable() -&gt; t|f</code></td>
<td>minimizable flag</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:isminimized() -&gt; t|f</code></td>
<td>check if the window is minimized</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:minimize()</code></td>
<td>minimize the window</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:minimized()</code></td>
<td>event: window was minimized</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:unminimized()</code></td>
<td>event: window was unminimized</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:maximizable() -&gt; t|f</code></td>
<td>maximizable flag</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:ismaximized() -&gt; t|f</code></td>
<td>check if the window is maximized</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:maximize()</code></td>
<td>maximize the window</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:maximized()</code></td>
<td>event: window was maximized</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:unmaximized()</code></td>
<td>event: window was unmaximized</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:fullscreenable() -&gt; t|f</code></td>
<td>fullscreenable flag</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:fullscreen(t|f) /-&gt; t|f</code></td>
<td>get/enter/exit fullscreen mode</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:entered_fullscreen()</code></td>
<td>event: entered fullscreen mode</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:exited_fullscreen()</code></td>
<td>event: exited fullscreen mode</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:restore()</code></td>
<td>restore from minimized or maximized state</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:shownormal()</code></td>
<td>show in normal state</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:showmodal()</code></td>
<td>show as modal window</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:changed(old_state, new_state)</code></td>
<td>event: window state changed</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>app:changed(old_state, new_state)</code></td>
<td>event: app state changed</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:enabled(t|f) /-&gt; t|f</code></td>
<td>get/set window enabled flag</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>frame extents</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>app:frame_extents(...) -&gt; ...</code></td>
<td>frame extents for a frame type</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>app:client_to_frame(...) -&gt; ...</code></td>
<td>client rect -&gt; window frame rect conversion</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>app:frame_to_client(...) -&gt; ...</code></td>
<td>window frame rect -&gt; client rect conversion</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>size and position</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:client_rect(x,y,w,h) /-&gt; x,y,w,h</code></td>
<td>get/set client rect</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:frame_rect(x,y,w,h) /-&gt; x,y,w,h</code></td>
<td>get/set frame rect</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:client_size(cw, ch) /-&gt; cw, ch</code></td>
<td>get/set client rect size</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win/view:to_screen(x, y) -&gt; x, y</code></td>
<td>client space -&gt; screen space conversion</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win/view:to_client(x, y) -&gt; x, y</code></td>
<td>screen space -&gt; client space conversion</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:normal_frame_rect() -&gt; x,y,w,h</code></td>
<td>get frame rect in normal state</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:sizing(when, how, rect)</code></td>
<td>event: window size/position is about to change</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:frame_rect_changed(x, y, w, h, ...)</code></td>
<td>event: window frame was moved and/or resized</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:frame_moved(x, y, oldx, oldy)</code></td>
<td>event: window frame was moved</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:frame_resized(w, h, oldw, oldh)</code></td>
<td>event: window frame was resized</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:client_rect_changed(cx,cy,cw,ch,...)</code></td>
<td>event: window client area was moved and/or resized</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:client_moved(cx, cy, oldcx, oldcy)</code></td>
<td>event: window client area was moved</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:client_resized(cw, ch, oldcw, oldch)</code></td>
<td>event: window client area was resized</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:hittest(x, y) -&gt; where</code></td>
<td>event: hit test for frameless windows</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>size constraints</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:resizeable() -&gt; t|f</code></td>
<td>resizeable flag</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:minsize(cw, ch) /-&gt; cw, ch</code></td>
<td>get/set min client rect size</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:maxsize(cw, ch) /-&gt; cw, ch</code></td>
<td>get/set max client rect size</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>window edge snapping</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:edgesnapping(mode) /-&gt; mode</code></td>
<td>get/set edge snapping mode</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:magnets(which) -&gt; {r1, ...}</code></td>
<td>event: get edge snapping rectangles</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>window z-order</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:topmost(t|f) /-&gt; t|f</code></td>
<td>get/set the topmost flag</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:raise([rel_to_win])</code></td>
<td>raise above all windows/specific window</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:lower([rel_to_win])</code></td>
<td>lower below all windows/specific window</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>window title</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:title(title) /-&gt; title</code></td>
<td>get/set title</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>displays</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>app:displays() -&gt; {disp1, ...}</code></td>
<td>get displays (in no specific order)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>app:main_display() -&gt; disp</code></td>
<td>the display whose screen rect starts at (0,0)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>app:active_display() -&gt; disp</code></td>
<td>the display which contains the active window</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>disp:screen_rect() -&gt; x, y, w, h</code></td>
<td>displayâs screen rectangle</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>disp.x, disp.y, disp.w, disp.h</code></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>disp:desktop_rect() -&gt; cx, cy, cw, ch</code></td>
<td>displayâs screen rectangle minus the taskbar</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>disp.cx, disp.cy, disp.cw, disp.ch</code></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>app:displays_changed()</code></td>
<td>event: displays changed</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:display() -&gt; disp|nil</code></td>
<td>the display the window is on</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>cursors</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:cursor(name|t|f) /-&gt; name, t|f</code></td>
<td>get/set the mouse cursor and visibility</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>app:caret_blink_time() -&gt; time | 1/0</code></td>
<td>caret blink time</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>frame flags</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:frame() -&gt; frame</code></td>
<td>windowâs frame: ânormalâ, ânoneâ, âtoolboxâ</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:transparent() -&gt; t|f</code></td>
<td>transparent flag</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:corner_radius() -&gt; n</code></td>
<td>rounded corners (0)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>child windows</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:parent() -&gt; win|nil</code></td>
<td>windowâs parent</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:children() -&gt; {win1, ...}</code></td>
<td>child windows</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:sticky() -&gt; t|f</code></td>
<td>sticky flag</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>hi-dpi support</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>app:autoscaling(t|f) /-&gt; t|f</code></td>
<td>get/enable/disable autoscaling</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>disp.scalingfactor</code></td>
<td>displayâs scaling factor</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:scalingfactor_changed()</code></td>
<td>event: a windowâs display scaling factor changed</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>views</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:views() -&gt; {view1, ...}</code></td>
<td>list views</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:view(t) -&gt; view</code></td>
<td>create a view</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>view:free()</code></td>
<td>destroy the view</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>view:dead() -&gt; t|f</code></td>
<td>check if the view was freed</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>view:visible(t|f) /-&gt; t|f</code></td>
<td>get/set viewâs visibility</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>view:show()</code></td>
<td>show the view</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>view:hide()</code></td>
<td>hide the view</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>view:rect(x, y, w, h) /-&gt; x, y, w, h</code></td>
<td>get/set viewâs position (in windowâs client space) and size</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>view:size(w, h) /-&gt; w, h</code></td>
<td>get/set viewâs size</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>view:anchors(anchors) /-&gt; anchors</code></td>
<td>get/set anchors</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>view:rect_changed(x, y, w, h)</code></td>
<td>event: viewâs size and/or position changed</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>view:moved(x, y, oldx, oldy)</code></td>
<td>event: view was moved</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>view:resized(w, h, oldw, oldh)</code></td>
<td>event: view was resized</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>keyboard</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>app:key(query) -&gt; t|f</code></td>
<td>get key pressed and toggle states</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:keydown(key)</code></td>
<td>event: a key was pressed</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:keyup(key)</code></td>
<td>event: a key was depressed</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:keypress(key)</code></td>
<td>event: sent after each keydown, including repeats</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:keychar(s)</code></td>
<td>event: input char pressed; <em>s</em> is utf-8</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>mouse</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>app:mouse(var) -&gt; val</code></td>
<td>mouse state: <em>x, y, pos</em></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win/view:mouse(var) -&gt; val</code></td>
<td>mouse state: <em>x, y, pos, inside, left, right, middle, x1, x2</em></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win/view:mouseenter(x, y)</code></td>
<td>event: mouse entered the client area of the window</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win/view:mouseleave()</code></td>
<td>event: mouse left the client area of the window</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win/view:mousemove(x, y)</code></td>
<td>event: mouse was moved</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win/view:mousedown(button, x, y, count)</code></td>
<td>event: mouse button was pressed</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win/view:mouseup(button, x, y, count)</code></td>
<td>event: mouse button was depressed</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win/view:click(button, count, x, y)</code></td>
<td>event: mouse button was clicked</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win/view:mousewheel(delta, x, y, pdelta)</code></td>
<td>event: mouse wheel was moved</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win/view:hmousewheel(delta, x, y, pdelta)</code></td>
<td>event: mouse horizontal wheel was moved</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>app:double_click_time() -&gt; time</code></td>
<td>double click time</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>app:double_click_target_area() -&gt; w, h</code></td>
<td>double click target area</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>rendering</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win/view:repaint()</code></td>
<td>event: needs repainting</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win/view:sync()</code></td>
<td>event: needs syncâing</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win/view:invalidate([invalid_clock])</code></td>
<td>request syncâing and repainting</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win/view:validate([at_clock])</code></td>
<td>request syncâing if invalid</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win/view:invalid([at_clock]) -&gt; t|f</code></td>
<td>check if invalidated</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win/view:bitmap() -&gt; bmp</code></td>
<td>get a bgra8 <a href="/bitmap">bitmap</a> object to draw on</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>bmp:clear()</code></td>
<td>fill the bitmap with zero bytes</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>bmp:cairo() -&gt; cr</code></td>
<td>get a cairo context on the bitmap</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win/view:free_cairo(cr)</code></td>
<td>event: cairo context needs freeing</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win/view:free_bitmap(bmp)</code></td>
<td>event: bitmap needs freeing</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win/view:gl() -&gt; gl</code></td>
<td>get an OpenGL context to draw with</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>menus</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>app:menu() -&gt; menu</code></td>
<td>create a menu (or menu bar)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>app:menubar() -&gt; menu</code></td>
<td>get appâs menu bar (OSX)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:menubar(menu|nil) /-&gt; menu|nil</code></td>
<td>get/set/remove windowâs menu bar (Windows, Linux)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win/view:popup(menu, cx, cy)</code></td>
<td>pop up a menu relative to a window or view</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>menu:popup(win/view, cx, cy)</code></td>
<td>pop up a menu relative to a window or view</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>menu:add(...)</code></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>menu:set(...)</code></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>menu:remove(index)</code></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>menu:get(index) -&gt; item</code></td>
<td>get the menu item at index</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>menu:get(index, prop) -&gt; val</code></td>
<td>get the value of a property of the menu item at index</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>menu:items([prop]) -&gt; {item1, ...}</code></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>menu:checked(index, t|f) /-&gt; t|f</code></td>
<td>get/set a menu itemâs checked state</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>icons (common API)</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>icon:free()</code></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>icon:bitmap() -&gt; bmp</code></td>
<td>get a bgra8 <a href="/bitmap">bitmap</a> object</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>icon:invalidate()</code></td>
<td>request repainting</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>icon:repaint()</code></td>
<td>event: bitmap needs redrawing</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>icon:free_bitmap(bmp)</code></td>
<td>event: bitmap needs freeing</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>notification icons</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>app:notifyicon(t) -&gt; icon</code></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>app:notifyicons() -&gt; {icon1, ...}</code></td>
<td>list notification icons</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>icon:tooltip(s) /-&gt; s</code></td>
<td>get/set iconâs tooltip</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>icon:menu(menu) /-&gt; menu</code></td>
<td>get/set iconâs menu</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>icon:text(s) /-&gt; s</code></td>
<td>get/set text (OSX)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>icon:length(n) /-&gt; n</code></td>
<td>get/set length (OSX)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>window icon (Windows)</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win:icon([which]) -&gt; icon</code></td>
<td>windowâs icon (âbigâ); which can be: âbigâ, âsmallâ</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>dock icon (OSX)</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>app:dockicon() -&gt; icon</code></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>file choose dialogs</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>app:opendialog(t) -&gt; path|{path1,...}|nil</code></td>
<td>open a standard âopen fileâ dialog</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>app:savedialog(t) -&gt; path|nil</code></td>
<td>open a standard âsave fileâ dialog</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>clipboard</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>app:getclipboard(format) -&gt; data|nil</code></td>
<td>get data in clipboard (format is âtextâ, âfilesâ, âbitmapâ)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>app:getclipboard() -&gt; formats</code></td>
<td>get data formats in clipboard</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>app:setclipboard(f|data[, format])</code></td>
<td>clear or set clipboard</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>drag &amp; drop</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win/view:dropfiles(x, y, files)</code></td>
<td>event: files are dropped</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win/view:dragging('enter',t,x,y) -&gt; s</code></td>
<td>event: mouse enter with payload</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win/view:dragging('hover',t,x,y) -&gt; s</code></td>
<td>event: mouse move with payload</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>win/view:dragging('drop',t,x,y)</code></td>
<td>event: dropped the payload</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win/view:dragging('leave')</code></td>
<td>event: mouse left with payload</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>tooltips</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>win:tooltip(text|f) -&gt; text|f</code></td>
<td>get/set/hide tooltip text</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>events</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>app/win/view:on(event, func)</code></td>
<td>call <em>func</em> when <em>event</em> happens</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>app/win/view:off(event)</code></td>
<td>remove event handlers</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>app/win/view:fire(event, args...) -&gt; ret</code></td>
<td>fire an event</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>app/win/view:events(enabled) -&gt; prev_state</code></td>
<td>enable/disable events</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>app/win/view:event(name, args...)</code></td>
<td>meta-event fired on every other event</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>version checks</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>app:ver(query) -&gt; t|f</code></td>
<td>check OS <em>minimum</em> version (eg. âOSX 10.8â)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>extending</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>nw.backends -&gt; {os -&gt; module_name}</code></td>
<td>default backend modules for each OS</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>nw:init([backend_name])</code></td>
<td>init with a specific backend (can be called only once)</td>
</tr>
</tbody>
</table>
<h2 id="the-app-object">The app object</h2>
<p>The global app object is the API from which everything else gets created.</p>
<h3 id="nwapp---app"><code>nw:app() -&gt; app</code></h3>
<p>Get the global application object.</p>
<p>This calls <code>nw:init()</code> which initializes the library with the default backend for the current platform.</p>
<h2 id="the-app-loop">The app loop</h2>
<h3 id="apprun"><code>app:run()</code></h3>
<p>Start the application main loop.</p>
<p>Calling run() when the loop is already running does nothing.</p>
<h3 id="appstop"><code>app:stop()</code></h3>
<p>Stop the loop.</p>
<p>Calling stop() when the loop is not running does nothing.</p>
<h3 id="apprunning---tf"><code>app:running() -&gt; t|f</code></h3>
<p>Check if the loop is running.</p>
<h3 id="apppolltimeout---tf"><code>app:poll([timeout]) -&gt; t|f</code></h3>
<p>Process the next pending event from the event queue. Returns <code>true</code> if there was an event to process, <code>false</code> if there wasnât. Returns <code>false, exit_code</code> if the application was asked to quit. <code>timeout</code> (default=0) specifies a maximum wait time for an event to appear.</p>
<h3 id="appmaxfpsfps-appmaxfps---fps"><code>app:maxfps(fps)</code> <br> <code>app:maxfps() -&gt; fps</code></h3>
<p>Get/set the maximum window repaint rate (frames per second). <code>1/0</code> disables the throttling. The default is <code>60</code>. Note that you still need to call <code>invalidate()</code> in order to trigger a repaint.</p>
<h2 id="quitting">Quitting</h2>
<h3 id="appquit"><code>app:quit()</code></h3>
<p>Quit the app, i.e.Â close all windows and stop the loop.</p>
<p>Quitting is a multi-phase process:</p>
<ol type="1">
<li><code>app:quitting()</code> event is fired. If it returns <code>false</code>, quitting is aborted.</li>
<li><code>win:closing('quit', closing_win)</code> event is fired on all non-child windows, with the initial window as arg#2. If any of them returns <code>false</code>, quitting is aborted.</li>
<li><code>win:free'force'</code> is called on all windows (in reverse-creation order).</li>
<li>the app loop is stopped.</li>
</ol>
<p>Calling <code>quit()</code> when the loop is not running or while quitting is in progress does nothing.</p>
<h3 id="appautoquit---tf-appautoquittf"><code>app:autoquit() -&gt; t|f</code> <br> <code>app:autoquit(t|f)</code></h3>
<p>Get/set the app autoquit flag (default: <code>true</code>). When this flag is <code>true</code>, the app loop exists when the last visible non-child window is closed.</p>
<h3 id="appquitting---false"><code>app:quitting() -&gt; [false]</code></h3>
<p>Event: the app wants to quit, but nothing was done to that effect. Return <code>false</code> from this event to cancel the process.</p>
<h3 id="winautoquit---tf-winautoquittf"><code>win:autoquit() -&gt; t|f</code> <br> <code>win:autoquit(t|f)</code></h3>
<p>Get/set the window autoquit flag (default: <code>false</code>). When this flag is <code>true</code>, the app loop exists when the window is closed. This flag can be used on the appâs main window if there is such a thing.</p>
<h2 id="timers">Timers</h2>
<h3 id="appruneveryseconds-func"><code>app:runevery(seconds, func)</code></h3>
<p>Run a function on a recurrent timer. The timer can be stopped by returning <code>false</code> from the function.</p>
<h3 id="apprunafterseconds-func"><code>app:runafter(seconds, func)</code></h3>
<p>Run a function on a timer once.</p>
<h3 id="apprunfunc"><code>app:run(func)</code></h3>
<p>Run a function on a zero-second timer, once, inside a coroutine. This allows calling <code>app:sleep()</code> inside the function (see below).</p>
<p>If the loop is not already started, it is started and then stopped after the function finishes.</p>
<h3 id="appsleepseconds"><code>app:sleep(seconds)</code></h3>
<p>Sleep without blocking from inside a function that was run via app:run(). While the function is sleeping, other timers and events continue to be processed.</p>
<p>This is poor manâs multi-threading based on timers and coroutines. It can be used to create complex temporal sequences withoug having to chain timer callbacks.</p>
<p>Calling sleep() outside an app:run() function raises an error.</p>
<h2 id="window-tracking">Window tracking</h2>
<h3 id="appwindowsfilter---win1-...-appwindows-filter---n"><code>app:windows([filter]) -&gt; {win1, ...}</code> <br> <code>app:windows('#'[, filter]) -&gt; n</code></h3>
<p>Get all windows in creation order. If â#â is given, get the number of windows (dead or alive) instead. An optional <code>filter(self, win) -&gt; false</code> function can be used to filter the results in both cases.</p>
<h3 id="appwindow_createdwin"><code>app:window_created(win)</code></h3>
<p>Event: a window was created.</p>
<h3 id="appwindow_closedwin"><code>app:window_closed(win)</code></h3>
<p>Event: a window was closed.</p>
<h2 id="creating-windows">Creating windows</h2>
<h3 id="appwindowt---win-appwindowcw-ch-title-visible---win"><code>app:window(t) -&gt; win</code> <br> <code>app:window(cw, ch, [title], [visible]) -&gt; win</code></h3>
<p>Create a window (fields of <em><code>t</code></em> below with default value in parenthesis):</p>
<ul>
<li><strong>position</strong>
<ul>
<li><code>x</code>, <code>y</code> - frame position</li>
<li><code>w</code>, <code>h</code> - frame size</li>
<li><code>cx</code>, <code>cy</code> - client area position</li>
<li><code>cw</code>, <code>ch</code> - client area size</li>
<li><code>min_cw</code>, <code>min_ch</code> - min client rect size (<code>1, 1</code>)</li>
<li><code>max_cw</code>, <code>max_ch</code> - max client rect size</li>
</ul></li>
<li><strong>state</strong>
<ul>
<li><code>visible</code> - start visible (<code>true</code>)</li>
<li><code>minimized</code> - start minimized (<code>false</code>)</li>
<li><code>maximized</code> - start maximized (<code>false</code>)</li>
<li><code>enabled</code> - start enabled (true)</li>
</ul></li>
<li><strong>frame</strong>
<ul>
<li><code>frame</code> - frame type: <code>'normal'</code>, <code>'none'</code>, <code>'toolbox'</code> (<code>'normal'</code>)</li>
<li><code>title</code> - title (<code>''</code>)</li>
<li><code>transparent</code> - transparent window (<code>false</code>)</li>
<li><code>corner_radius</code> - rounded corners (<code>0</code>)</li>
</ul></li>
<li><strong>behavior</strong>
<ul>
<li><code>parent</code> - parent window</li>
<li><code>sticky</code> - moves with parent (<code>false</code>)</li>
<li><code>topmost</code> - stays on top of other non-topmost windows (<code>false</code>)</li>
<li><code>minimizable</code> - allow minimization (<code>true</code>)</li>
<li><code>maximizable</code> - allow maximization (<code>true</code>; <code>false</code> if <code>resizeable</code> is <code>false</code>)</li>
<li><code>closeable</code> - allow closing (<code>true</code>)</li>
<li><code>resizeable</code> - allow resizing (<code>true</code>)</li>
<li><code>fullscreenable</code> - allow fullscreen mode (<code>true</code>; <code>false</code> if <code>resizeable</code> is <code>false</code>)</li>
<li><code>activable</code> - allow activation (<code>true</code>)</li>
<li><code>autoquit</code> - quit the app on closing (<code>false</code>)</li>
<li><code>hideonclose</code> - hide on close instead of destroying (<code>true</code>)</li>
<li><code>edgesnapping</code> - magnetized edges (<code>'screen'</code>)</li>
</ul></li>
<li><strong>rendering</strong>
<ul>
<li><code>opengl</code> - enable and <a href="#winviewgl---gl">configure OpenGL</a> on the window</li>
</ul></li>
<li><strong>menu</strong>
<ul>
<li><code>menu</code> - the menu bar</li>
</ul></li>
<li><strong>tooltip</strong>
<ul>
<li><code>tooltip</code> - tooltip text (<code>false</code>)</li>
</ul></li>
</ul>
<h3 id="initial-size-and-position">Initial size and position</h3>
<p>You can pass any combination of <code>x</code>, <code>y</code>, <code>w</code>, <code>h</code>, <code>cx</code>, <code>cy</code>, <code>cw</code>, <code>ch</code> as long as you pass both the width and the height in one way or another. The position is optional and it defaults to OS-driven cascading.</p>
<p>Additionally, <code>x</code> and/or <code>y</code> can be <code>'center-main'</code> or <code>'center-active'</code> which will center the window on the main or active display respectively.</p>
<p>If the size is max-constrained by either <code>max_cw</code>, <code>max_ch</code> or <code>resizeable = false</code> then <code>maximizable = false</code> and <code>fullscreenable = false</code> must also be set.</p>
<p>Expect the OS to adjust the window size and/or position in unspecified ways for off-screen windows, windows too small to fit all titlebar buttons, windows with zero or negative client size or windows that are very large. Some adjustments are delayed to when the window is shown.</p>
<h3 id="the-window-state">The window state</h3>
<p>The window state is the combination of multiple flags (<code>minimized</code>, <code>maximized</code>, <code>fullscreen</code>, <code>visible</code>, <code>active</code>) plus its position, size and frame in current state (<code>client_rect</code> and <code>frame_rect</code>), and in normal state (<code>normal_frame_rect</code>).</p>
<p>State flags are independent of each other, so they can be in almost any combination at the same time. For example, a window which starts with <code>{visible = false, minimized = true, maximized = true}</code> is initially hidden. If later made visible with <code>win:show()</code>, it will show minimized. If the user then unminimizes it, it will restore to maximized state. Throughout all these stages the <code>maximized</code> flag is <code>true</code>.</p>
<h3 id="coordinate-systems">Coordinate systems</h3>
<ul>
<li>window-relative positions are relative to the top-left corner of the windowâs client area.</li>
<li>screen-relative positions are relative to the top-left corner of the main screen.</li>
</ul>
<h2 id="child-windows">Child windows</h2>
<p>Child windows (<code>parent = win</code>) are top-level windows (so framed, not clipped) that stay on top of their parent, minimize along with their parent, and donât appear in the taskbar.</p>
<p>The following defaults are different for child windows:</p>
<ul>
<li><code>minimizable</code>: false (must be false)</li>
<li><code>maximizable</code>: false</li>
<li><code>fullscreenable</code>: false</li>
<li><code>edgesnapping</code>: âparent siblings screenâ</li>
<li><code>sticky</code>: true</li>
</ul>
<p>Child windows canât be minimizable because they donât appear in the taskbar (they minimize when their parent is minimized). Child windows remain visible if their parent is hidden (or is created hidden).</p>
<h3 id="winparent---winnil"><code>win:parent() -&gt; win|nil</code></h3>
<p>Get the windowâs parent (read-only).</p>
<h3 id="winchildren---win1-..."><code>win:children() -&gt; {win1, ...}</code></h3>
<p>Get the windowâs children (those whose parent() is this window).</p>
<h3 id="sticky-windows">Sticky windows</h3>
<p>Sticky windows (<code>sticky = true</code>) follow their parent when their parent is moved.</p>
<p><strong>NOTE:</strong> Sticky windows <a href="https://github.com/luapower/nw/issues/27">donât work</a> on Linux.</p>
<h3 id="winsticky---tf"><code>win:sticky() -&gt; t|f</code></h3>
<p>Get the sticky flag (read-only).</p>
<h3 id="toolbox-windows">Toolbox windows</h3>
<p>Toolbox windows (<code>frame = 'toolbox'</code>) show a thin title bar on Windows (they show a normal frame on OSX and Linux). They must have a parent.</p>
<h2 id="transparent-windows">Transparent windows</h2>
<p>Transparent windows (<code>transparent = true</code>) allow using the full alpha channel when drawing on them. They also come with serious limitations (mostly from Windows):</p>
<ul>
<li>they canât be framed so you must pass <code>frame = 'none'</code>.</li>
<li>they canât have views.</li>
<li>you canât draw on them using OpenGL.</li>
</ul>
<p>Despite these limitations, transparent windows are the only way to create free-floating tooltips and custom-shaped notification windows.</p>
<h3 id="wintransparent---tf"><code>win:transparent() -&gt; t|f</code></h3>
<p>Get the transparent flag (read-only).</p>
<h2 id="window-closing">Window closing</h2>
<p>Closing the window hides it or destroys it depending on the <code>hideonclose</code> flag. You can prevent closing by returning <code>false</code> in the <code>win:closing()</code> event.</p>
<h3 id="wincloseforce"><code>win:close([force])</code></h3>
<p>Close the window. Children are closed first. The <code>force</code> arg allows closing the window without firing the <code>win:closing()</code> event.</p>
<p>Calling <code>close()</code> on a closed window does nothing.</p>
<p>Closing a window results in hiding it or freeing it, depending on the <code>hideonclose</code> flag.</p>
<h3 id="windead---tf"><code>win:dead() -&gt; t|f</code></h3>
<p>Check if the window was destroyed. Calling any other method on a dead window raises an error.</p>
<h3 id="winclosingreason-closing_win"><code>win:closing(reason, [closing_win])</code></h3>
<p>Event: The window is about to close. Reason can be <code>'quit'</code>, <code>'close'</code>, or the first argument passed to <code>close()</code>. When reason is <code>'close'</code>, <code>closing_win</code> is the window initiating the process. Return <code>false</code> from the event handler to refuse closing.</p>
<h3 id="winclosed"><code>win:closed()</code></h3>
<p>Event: The window was closed and is about to be destroyed. Fired after all children are closed, but before the window itself is destroyed. This event does not fire when <code>hideonclose</code> is <code>true</code> and the window is closed by the user or by calling <code>close()</code> (check the <code>hidden</code> event then).</p>
<h3 id="wincloseable---tf"><code>win:closeable() -&gt; t|f</code></h3>
<p>Get the closeable flag (read-only).</p>
<h3 id="winhideonclosetf---tf"><code>win:hideonclose(t|f) /-&gt; t|f</code></h3>
<p>What to do when a window is closed: hide it or destroying it.</p>
<h3 id="winfreeforce"><code>win:free([force])</code></h3>
<p>Close and destroy the window (same as <code>close()</code> when <code>hideonclose</code> is set to <code>false</code>).</p>
<p><strong>NOTE:</strong> Ensure that all the windows are freed before the process exits (which is why the <code>autoquit</code> option calls <code>free()</code> on the windows instead of <code>close()</code> which might just hide them). Donât leave it to the gc to free window objects because a window object contains other gcâed objects that need to be freed in a specific order but the order in which <code>ffi.gc</code> destructors are called is undefined when the window object is gcâed.</p>
<h2 id="window-app-activation">Window &amp; app activation</h2>
<p>Activation is about app activation and window activation. Activating a window programatically has an immediate effect only while the app is active. If the app is inactive, the window is not activated until the app becomes active and the user is notified in some other less intrusive way.</p>
<p>If the user activates a different app in the interval between app launch and first window being shown, the app wonât be activated back (this is a good thing usability-wise). This doesnât work on Linux (new windows always pop in your face because thereâs no concept of an âappâ really in X).</p>
<h3 id="appactive---tf"><code>app:active() -&gt; t|f</code></h3>
<p>Check if the app is active.</p>
<h3 id="appactivatemode"><code>app:activate([mode])</code></h3>
<p>Activate the app, which activates the last window that was active before the app got deactivated.</p>
<p>The <em>mode</em> arg can be:</p>
<ul>
<li>âalertâ (default; Windows and OSX only; on Linux it does nothing)</li>
<li>âforceâ (OSX and Linux only; on Windows itâs the same as âalertâ)</li>
<li>âinfoâ (OSX only; on Windows itâs the same as âalertâ; on Linux it does nothing)</li>
</ul>
<p>The âalertâ mode: on Windows, this flashes the window on the taskbar until the user activates the window. On OSX it bounces the dock icon until the user activates the app. On Linux it does nothing.</p>
<p>The âforceâ mode: on Windows this is the same as the âalertâ mode. On OSX and Linux it pops up the window in the userâs face (very rude, donât do it).</p>
<p>The âinfoâ mode: this special mode allows bouncing up the dock icon on OSX only once. On other platforms itâs the same as the default âalertâ mode.</p>
<h3 id="appactivated-appdeactivated"><code>app:activated()</code> <br> <code>app:deactivated()</code></h3>
<p>Event: the app was activated/deactivated.</p>
<h3 id="appactive_window---winnil"><code>app:active_window() -&gt; win|nil</code></h3>
<p>Get the active window, if any (nil if the app is inactive).</p>
<h3 id="winactive---tf"><code>win:active() -&gt; t|f</code></h3>
<p>Check if the window is active (<code>false</code> for all windows if the app is inactive).</p>
<h3 id="winactivate"><code>win:activate()</code></h3>
<p>Activate the window. If the app is inactive, this does <em>not</em> activate the window. Instead it only marks the window to be activated when the app becomes active. If you want to alert the user that it should pay attention to the app/window, call <code>app:activate()</code> after calling this function.</p>
<h3 id="winactivated-windeactivated"><code>win:activated()</code> <br> <code>win:deactivated()</code></h3>
<p>Event: window was activated/deactivated.</p>
<h3 id="winactivable---tf"><code>win:activable() -&gt; t|f</code></h3>
<p>Get the activable flag (read-only). This is useful for creating popup menus that can be clicked on without stealing keyboard focus away from the main window.</p>
<p><strong>NOTE:</strong> Only works with frameless windows.</p>
<p><strong>NOTE:</strong> This <a href="https://github.com/luapower/nw/issues/26">doesnât work</a> in Linux.</p>
<h2 id="app-instances">App instances</h2>
<h3 id="appcheck_single_instance"><code>app:check_single_instance()</code></h3>
<p>If another instance of this app is already running, activate it and exit this process. Calling this at the beginning of the app (after setting <code>nw.app_id</code> if thatâs necessasry) is enough to enable single-app instance behavior.</p>
<h3 id="nw.app_id-id"><code>nw.app_id = id</code></h3>
<p>Set the app ID for single-app-instance checks. All processes with the same app ID will be considered instances of the same app. If this is not set, the executable file which started the process is used as app ID.</p>
<p><strong>NOTE:</strong> This must be set before calling <code>nw:app()</code> for the first time.</p>
<h3 id="appalready_running---tf"><code>app:already_running() -&gt; t|f</code></h3>
<p>Check if other instances of this app are running.</p>
<h3 id="appwakeup_other_instances"><code>app:wakeup_other_instances()</code></h3>
<p>Send <code>wakeup</code> event to other instances of this app.</p>
<h3 id="appwakeup"><code>app:wakeup()</code></h3>
<p>Event: another instance of this app has called <code>app:wakeup_other_instances()</code>.</p>
<h2 id="app-visibility-osx">App visibility (OSX)</h2>
<h3 id="appvisible---tf-appvisibletf-apphide-appunhide"><code>app:visible() -&gt; t|f</code> <br> <code>app:visible(t|f)</code> <br> <code>app:hide()</code> <br> <code>app:unhide()</code></h3>
<p>Get/set app visibility.</p>
<h3 id="apphidden-appunhidden"><code>app:hidden()</code> <br> <code>app:unhidden()</code></h3>
<p>Event: app was hidden/unhidden.</p>
<h2 id="window-state">Window state</h2>
<h3 id="winshow"><code>win:show()</code></h3>
<p>Show the window in its previous state (which can include any combination of minimized, maximized, and fullscreen state flags).</p>
<p>When a hidden window is shown it is also activated, except if it was previously minimized, in which case it is shown in minimized state without being activated.</p>
<p>Calling show() on a visible (which includes minimized) window does nothing.</p>
<h3 id="winhide"><code>win:hide()</code></h3>
<p>Hide the window from the screen and from the taskbar, preserving its full state.</p>
<p>Calling hide() on a hidden window does nothing.</p>
<h3 id="winvisible---tf"><code>win:visible() -&gt; t|f</code></h3>
<p>Check if a window is visible (note: that includes minimized).</p>
<h3 id="winvisibletf"><code>win:visible(t|f)</code></h3>
<p>Calls <code>show()</code> or <code>hide()</code> to change the windowâs visibility.</p>
<h3 id="winshown-winhidden"><code>win:shown()</code> <br> <code>win:hidden()</code></h3>
<p>Event: window was shown/hidden.</p>
<h3 id="winminimizable---tf"><code>win:minimizable() -&gt; t|f</code></h3>
<p>Get the minimizable flag (read-only).</p>
<h3 id="winisminimized---tf"><code>win:isminimized() -&gt; t|f</code></h3>
<p>Get the minimized state. This flag remains <code>true</code> when a minimized window is hidden.</p>
<h3 id="winminimize"><code>win:minimize()</code></h3>
<p>Minimize the window and deactivate it. If the window is hidden, it is shown in minimized state (and the taskbar button is not activated).</p>
<h3 id="winminimized-winunminimized"><code>win:minimized()</code> <br> <code>win:unminimized()</code></h3>
<p>Event: window was minimized/unminimized.</p>
<h3 id="winmaximizable---tf"><code>win:maximizable() -&gt; t|f</code></h3>
<p>Get the maximizable flag (read-only).</p>
<h3 id="winismaximized---tf"><code>win:ismaximized() -&gt; t|f</code></h3>
<p>Get the maximized state. This flag stays <code>true</code> if a maximized window is minimized, hidden or enters fullscreen mode.</p>
<h3 id="winmaximize"><code>win:maximize()</code></h3>
<p>Maximize the window and activate it. If the window was hidden, it is shown in maximized state and activated.</p>
<p>If the window is already maximized it is not activated.</p>
<h3 id="winmaximized-winunmaximized"><code>win:maximized()</code> <br> <code>win:unmaximized()</code></h3>
<p>Event: window was maximized/unmaximized.</p>
<h3 id="winfullscreenable---tf"><code>win:fullscreenable() -&gt; t|f</code></h3>
<p>Check if a window is allowed to go in fullscreen mode (read-only). This flag only affects OSX - the only platform which presents a fullscreen button on the title bar. Fullscreen mode can always be engaged programatically.</p>
<h3 id="winfullscreen---tf"><code>win:fullscreen() -&gt; t|f</code></h3>
<p>Get the fullscreen state.</p>
<h3 id="winfullscreentf"><code>win:fullscreen(t|f)</code></h3>
<p>Enter or exit fullscreen mode and activate the window. If the window is hidden or minimized, it is shown in fullscreen mode and activated.</p>
<p>If the window is already in the desired mode it is not activated.</p>
<h3 id="winentered_fullscreen-winexited_fullscreen"><code>win:entered_fullscreen()</code> <br> <code>win:exited_fullscreen()</code></h3>
<p>Event: entered/exited fullscreen mode.</p>
<h3 id="winrestore"><code>win:restore()</code></h3>
<p>Restore from minimized, maximized or fullscreen state, i.e.Â unminimize if the window was minimized, exit fullscreen if it was in fullscreen mode, or unmaximize it if it was maximized (otherwise do nothing).</p>
<p>The window is always activated unless it was in normal mode.</p>
<h3 id="winshownormal"><code>win:shownormal()</code></h3>
<p>Show the window in normal state.</p>
<p>The window is always activated even when itâs already in normal mode.</p>
<p>State tracking is about getting and tracking the entire user-changeable state of a window (of or the app) as a whole.</p>
<h3 id="winshowmodal"><code>win:showmodal()</code></h3>
<p>Show as modal window to its parent. A modal window disables its parent while it is visible and enables it back when it gets hidden again. The window must be activable and must have a parent or an error is raised.</p>
<h3 id="winchangedold_state-new_state"><code>win:changed(old_state, new_state)</code></h3>
<p>Event: window user-changeable state (i.e.Â any of the <code>visible</code>, <code>minimized</code>, <code>maximized</code>, <code>fullscreen</code> or <code>active</code> flags) has changed.</p>
<h3 id="appchangedold_state-new_state"><code>app:changed(old_state, new_state)</code></h3>
<p>Event: app user-changeable state (i.e.Â the <code>visible</code> or <code>active</code> flag) has changed.</p>
<h3 id="winenabled---tf-winenabledtf"><code>win:enabled() -&gt; t|f</code> <br> <code>win:enabled(t|f)</code></h3>
<p>Get/set the enabled flag (default: true). A disabled window cannot receive mouse or keyboard focus. Disabled windows are useful for implementing modal windows: make a child window and disable the parent while showing the child, and enable back the parent when closing the child.</p>
<p><strong>NOTE:</strong> This <a href="https://github.com/luapower/nw/issues/25">doesnât work</a> on Linux.</p>
<h2 id="frame-extents">Frame extents</h2>
<h3 id="appframe_extentsframe-has_menu-resizeable---left-top-right-bottom"><code>app:frame_extents(frame, has_menu, resizeable) -&gt; left, top, right, bottom</code></h3>
<p>Get the frame extents for a certain frame type. If <code>has_menu</code> is <code>true</code>, then the window also has a menu.</p>
<h3 id="appclient_to_frameframe-has_menu-resizeable-x-y-w-h---x-y-w-h"><code>app:client_to_frame(frame, has_menu, resizeable, x, y, w, h) -&gt; x, y, w, h</code></h3>
<p>Given a client rectangle, return the frame rectangle for a certain frame type. If <code>has_menu</code> is <code>true</code>, then the window also has a menu.</p>
<h3 id="appframe_to_clientframe-has_menu-resizeable-x-y-w-h---x-y-w-h"><code>app:frame_to_client(frame, has_menu, resizeable, x, y, w, h) -&gt; x, y, w, h</code></h3>
<p>Given a frame rectangle, return the client rectangle for a certain frame type. If <code>has_menu</code> is <code>true</code>, then the window also has a menu.</p>
<h2 id="size-and-position">Size and position</h2>
<h3 id="winclient_rect---cx-cy-cw-ch-winclient_rectcx-cy-cw-ch-winframe_rect---x-y-w-h-winframe_rectx-y-w-h-winclient_size---cw-ch-winclient_sizecw-ch"><code>win:client_rect() -&gt; cx, cy, cw, ch</code> <br> <code>win:client_rect(cx, cy, cw, ch)</code> <br> <code>win:frame_rect() -&gt; x, y, w, h</code> <br> <code>win:frame_rect(x, y, w, h)</code> <br> <code>win:client_size() -&gt; cw, ch</code> <br> <code>win:client_size(cw, ch)</code></h3>
<p>Get/set the client/frame rect/size in screen coordinates.</p>
<p>When getting: returns nothing if the window is minimized.</p>
<p>When setting: if any of the arguments is nil or <code>false</code>, it is replaced with the current value of that argument to allow for partial changes. Does nothing if the window is minimized, maximized, or in fullscreen mode.</p>
<h3 id="winviewto_screenx-y---x-y-winviewto_clientx-y---x-y"><code>win/view:to_screen(x, y) -&gt; x, y</code> <br> <code>win/view:to_client(x, y) -&gt; x, y</code></h3>
<p>Convert a point from client space to screen space and viceversa based on client_rect().</p>
<h3 id="winnormal_frame_rect---x-y-w-h"><code>win:normal_frame_rect() -&gt; x, y, w, h</code></h3>
<p>Get the frame rect in normal state (in screen coordinates). Unlinke client_rect() and frame_rect(), this always returns a rectangle. This is useful for recreating a window in its previous state which includes the normal frame rectangle, the maximized flag, and optionally the minimized flag. It doesnât include the fullscreen flag (you cannot create a window in fullscreen mode but you can enter fullscreen mode afterwards).</p>
<h3 id="winsizingwhen-how-rect---truenil"><code>win:sizing(when, how, rect) -&gt; true|nil</code></h3>
<p>Event: window size/position is about to change. The <code>rect</code> arg is a table with the fields <em>x, y, w, h</em>. Change these values in the table to affect the windowâs final size and position.</p>
<p><strong>NOTE:</strong> This event does not fire in Linux.</p>
<h3 id="winclient_rect_changedcx-cy-cw-ch-oldcx-oldcy-oldcw-oldch-winclient_movedcx-cy-oldcx-oldcy-winclient_resizedcw-ch-oldcw-oldch-winframe_rect_changedx-y-w-h-oldx-oldy-oldw-oldh-winframe_movedx-y-oldx-oldy-winframe_resizedw-h-oldw-oldh"><code>win:client_rect_changed(cx, cy, cw, ch, oldcx, oldcy, oldcw, oldch)</code> <br> <code>win:client_moved(cx, cy, oldcx, oldcy)</code> <br> <code>win:client_resized(cw, ch, oldcw, oldch)</code> <br> <code>win:frame_rect_changed(x, y, w, h, oldx, oldy, oldw, oldh)</code> <br> <code>win:frame_moved(x, y, oldx, oldy)</code> <br> <code>win:frame_resized(w, h, oldw, oldh)</code></h3>
<p>Event: window was moved/resized. These events also fire when a window is hidden or minimized in which case all args are nil, so make sure to test for that.</p>
<p>These events fire together every time in the same order:</p>
<ul>
<li><code>client_rect_changed</code></li>
<li><code>client_moved</code></li>
<li><code>client_resized</code></li>
<li><code>frame_rect_changed</code></li>
<li><code>frame_moved</code></li>
<li><code>frame_resized</code></li>
</ul>
<h3 id="winhittestx-y-where---where"><code>win:hittest(x, y, where) -&gt; where</code></h3>
<p>Hit test for moving and resizing frameless windows. Return âleftâ, âtopâ, ârightâ, âbottomâ, âtopleftâ, âbottomrightâ, âtoprightâ or âbottomleftâ to specify that the window should be resized, âmoveâ which means the window should be moved, <code>false</code> which means the coordinates are over the client area, or nil which means that standard resizing should take place. The <code>where</code> arg is the default response for the given coordinates.</p>
<h2 id="size-constraints">Size constraints</h2>
<h3 id="winresizeable---tf"><code>win:resizeable() -&gt; t|f</code></h3>
<p>Check if the window is resizeable.</p>
<h3 id="winminsize---cw-ch-winminsizecw-ch-winminsizefalse"><code>win:minsize() -&gt; cw, ch</code> <br> <code>win:minsize(cw, ch)</code> <br> <code>win:minsize(false)</code></h3>
<p>Get/set/clear the minimum client rect size.</p>
<p>The constraint can be applied to one dimension only by passing <code>false</code> or nil for the other dimension. The window is resized if it was smaller than this size. The size is clamped to maxsize if that is set. The size is finally clamped to the minimum (1, 1) which is also the default.</p>
<h3 id="winmaxsize---cw-ch-winmaxsizecw-ch-winmaxsizefalse"><code>win:maxsize() -&gt; cw, ch</code> <br> <code>win:maxsize(cw, ch)</code> <br> <code>win:maxsize(false)</code></h3>
<p>Get/set/clear the maximum client rect size.</p>
<p>The constraint can be applied to one dimension only by passing <code>false</code> or nil for the other dimension. The window is resized if it was larger than this size. The size is clamped to minsize if that is set. Trying to set this on a maximizable or fullscreenable window raises an error.</p>
<h2 id="edge-snapping">Edge snapping</h2>
<h3 id="winedgesnapping---mode-winedgesnappingmode"><code>win:edgesnapping() -&gt; mode</code> <br> <code>win:edgesnapping(mode)</code></h3>
<p>Get/set edge snapping mode, which is a string containing any combination of the following words separated by spaces:</p>
<ul>
<li><code>'app'</code> - snap to appâs windows</li>
<li><code>'other'</code> - snap to other appsâ windows</li>
<li><code>'parent'</code> - snap to parent window</li>
<li><code>'siblings'</code> - snap to sibling windows</li>
<li><code>'screen'</code> or <code>true</code> - snap to screen edges</li>
<li><code>'all'</code> - equivalent to âapp other screenâ</li>
<li><code>false</code> - disable snapping</li>
</ul>
<p><strong>NOTE:</strong> Edge snapping doesnât work on Linux because the <code>win:sizing()</code> event doesnât fire there. It is however already (poorly) implemented by some window managers (eg. Unity) so all is not lost.</p>
<h3 id="winmagnetswhich---r1-..."><code>win:magnets(which) -&gt; {r1, ...}</code></h3>
<p>Event: get edge snapping rectangles (rectangles are tables with fields <em>x, y, w, h</em>).</p>
<h2 id="z-order">Z-Order</h2>
<h3 id="wintopmost---tf-wintopmosttf"><code>win:topmost() -&gt; t|f</code> <br> <code>win:topmost(t|f)</code></h3>
<p>Get/set the topmost flag. A topmost window stays on top of all other non-topmost windows.</p>
<h3 id="winraiserel_to_win"><code>win:raise([rel_to_win])</code></h3>
<p>Raise above all windows/specific window.</p>
<h3 id="winlowerrel_to_win"><code>win:lower([rel_to_win])</code></h3>
<p>Lower below all windows/specific window.</p>
<h2 id="window-title">Window title</h2>
<h3 id="wintitle---title-wintitletitle"><code>win:title() -&gt; title</code> <br> <code>win:title(title)</code></h3>
<p>Get/set the windowâs title.</p>
<h2 id="displays">Displays</h2>
<p>In multi-monitor setups, the non-mirroring displays are mapped on a virtual surface, with the main displayâs top-left corner at (0, 0).</p>
<h3 id="appdisplays---disp1-...-appdisplays---n"><code>app:displays() -&gt; {disp1, ...}</code> <br> <code>app:displays'#' -&gt; n</code></h3>
<p>Get displays (in no specific order). Mirroring displays are not included. If â#â is given, get the display count instead.</p>
<h3 id="appmain_display---disp"><code>app:main_display() -&gt; disp</code></h3>
<p>Get the display whose screen rect is at (0, 0).</p>
<h3 id="appactive_display---disp"><code>app:active_display() -&gt; disp</code></h3>
<p>Get the display which contains the active window, falling back to the main display if there is no active window.</p>
<h3 id="dispscreen_rect---x-y-w-h-disp.x-disp.y-disp.w-disp.h"><code>disp:screen_rect() -&gt; x, y, w, h</code> <br> <code>disp.x, disp.y, disp.w, disp.h</code></h3>
<p>Get the displayâs screen rectangle.</p>
<h3 id="dispdesktop_rect---cx-cy-cw-ch-disp.cx-disp.cy-disp.cw-disp.ch"><code>disp:desktop_rect() -&gt; cx, cy, cw, ch</code> <br> <code>disp.cx, disp.cy, disp.cw, disp.ch</code></h3>
<p>Get the displayâs desktop rectangle (screen minus any taskbars).</p>
<p><strong>NOTE:</strong> This doesnât work in Linux for secondary monitors (it gives the screen rect).</p>
<h3 id="appdisplays_changed"><code>app:displays_changed()</code></h3>
<p>Event: displays changed.</p>
<h3 id="windisplay---dispnil"><code>win:display() -&gt; disp|nil</code></h3>
<p>Get the display the window is currently on. Returns nil if the window is off-screen. Returns the correct display based on the windowâs coordinates even if the window is hidden.</p>
<h2 id="cursors">Cursors</h2>
<h3 id="wincursor---name-tf-wincursornametf"><code>win:cursor() -&gt; name, t|f</code> <br> <code>win:cursor(name|t|f)</code></h3>
<p>Get/set the mouse cursor and/or visibility. The name can be:</p>
<ul>
<li>âarrowâ (default)</li>
<li>âtextâ</li>
<li>âhandâ</li>
<li>âcrossâ</li>
<li>âforbiddenâ</li>
<li>âsize_diag1â (i.e.Â NE-SW, forward-slash-looking)</li>
<li>âsize_diag2â (i.e.Â NW-SE, backslash-looking)</li>
<li>âsize_hâ</li>
<li>âsize_vâ</li>
<li>âmoveâ</li>
<li>âbusy_arrowâ</li>
<li>âtopâ, âleftâ, ârightâ, âbottomâ, âtopleftâ, âtoprightâ, âbottomleftâ, âbottomrightâ (only different in Linux)</li>
</ul>
<h2 id="keyboard">Keyboard</h2>
<p>See <a href="/nw_keyboard">nw_keyboard</a> for the list of key names.</p>
<h3 id="appkeyquery---tf"><code>app:key(query) -&gt; t|f</code></h3>
<p>Get key pressed and toggle states. The query can be one or more key names separated by spaces or by <code>+</code> eg. âalt+f3â or âalt f3â.</p>
<p>The key name can start with <code>^</code> in which case the toggle state of that key is queried instead eg. â^capslockâ returns the toggle state of the caps lock key while âcapslockâ returns its pressed state. (only the capslock, numlock and scrolllock keys have toggle states).</p>
<p>The key name can start with <code>!</code> which checks that the key is <em>not</em> pressed.</p>
<h3 id="winkeydownkey"><code>win:keydown(key)</code></h3>
<p>Event: a key was pressed (not sent on repeat).</p>
<h3 id="winkeyupkey"><code>win:keyup(key)</code></h3>
<p>Event: a key was depressed.</p>
<h3 id="winkeypresskey"><code>win:keypress(key)</code></h3>
<p>Event: sent after keydown and on key repeat.</p>
<h3 id="winkeychars"><code>win:keychar(s)</code></h3>
<p>Event: sent after keypress for displayable characters; <em><code>s</code></em> is a utf-8 string and can contain one or more code points.</p>
<h2 id="hi-dpi-support">Hi-DPI support</h2>
<p>By default, windows contents are scaled by the OS on Hi-DPI screens, so they look blurry but they are readable even if the app is unaware that it is showing on a dense screen. Making the app Hi-DPI-aware means telling the OS to disable this automatic raster scaling and allow the app to scale the UI itself (but this time in vector space) in order to make it readable again on a dense screen.</p>
<h3 id="appautoscaling---tf"><code>app:autoscaling() -&gt; t|f</code></h3>
<p>Check if autoscaling is enabled.</p>
<h3 id="appautoscalingtf"><code>app:autoscaling(t|f)</code></h3>
<p>Enable/disable autoscaling.</p>
<p><strong>NOTE:</strong> This function must be called before the OS stretcher kicks in, i.e.Â before creating any windows or calling any display APIs. It will silently fail otherwise.</p>
<h3 id="disp.scalingfactor"><code>disp.scalingfactor</code></h3>
<p>The displayâs scaling factor is an attribute of display objects. This is 1 when autoscaling is enabled and &gt; 1 when disabled and the display is hi-dpi.</p>
<p>If autoscaling is disabled, windows must check their displayâs scaling factor and scale the UI accordingly.</p>
<h3 id="winscalingfactor_changed"><code>win:scalingfactor_changed()</code></h3>
<p>A windowâs display scaling factor changed or most likely the window was moved to a screen with a different scaling factor.</p>
<h2 id="views">Views</h2>
<p>A view object defines a rectangular region within a window for drawing and receiving mouse events.</p>
<p>Views allow partitioning a windowâs client area into multiple non-overlapping regions that can be rendered using different technologies. In particular, you can use OpenGL on some views, while using bitmaps (and thus cairo) on others. This presents a simple solution to the problem of drawing an antialiased 2D UI around a 3D scene as an alternative to drawing on the textures of orto-projected quads. Views also allow placing native widgets alongside custom-painted areas on the same window.</p>
<p><strong>NOTE:</strong> If you use views, bind all mouse events to the views. Do not mix window and view mouse events since the behavior of window mouse events in the presence of views is <a href="https://github.com/luapower/nw/issues/54">not consistent</a> between platforms.</p>
<h3 id="winviews---view1-...-winviews---n"><code>win:views() -&gt; {view1, ...}</code> <br> <code>win:views'#' -&gt; n</code></h3>
<p>Get the windowâs views. If â#â is given, get the view count instead.</p>
<h3 id="winviewt---view"><code>win:view(t) -&gt; view</code></h3>
<p>Create a view (fields of <em><code>t</code></em> below):</p>
<ul>
<li><code>x</code>, <code>y</code>, <code>w</code>, <code>h</code> - viewâs position (in windowâs client space) and size</li>
<li><code>visible</code> - start visible (default: true)</li>
<li><code>anchors</code> - resizing anchors (default: âltâ); can be âltrbâ</li>
<li><code>opengl</code> - enable and <a href="#winviewgl---gl">configure OpenGL</a> on the view.</li>
</ul>
<p><strong>NOTE:</strong> The width and height are clamped to the minimum (1, 1).</p>
<h3 id="viewfree"><code>view:free()</code></h3>
<p>Destroy the view.</p>
<h3 id="viewdead---tf"><code>view:dead() -&gt; t|f</code></h3>
<p>Check if the view was destroyed.</p>
<h3 id="viewvisible---tf-viewvisibletf-viewshow-viewhide"><code>view:visible() -&gt; t|f</code> <br> <code>view:visible(t|f)</code> <br> <code>view:show()</code> <br> <code>view:hide()</code></h3>
<p>Get/set the viewâs visibility.</p>
<p>The position and size of the view are preserved while hidden (anchors keep working).</p>
<h3 id="viewrect---x-y-w-h-viewrectx-y-w-h"><code>view:rect() -&gt; x, y, w, h</code> <br> <code>view:rect(x, y, w, h)</code></h3>
<p>Get/set the viewâs position (in windowâs client space) and size.</p>
<p>The view rect is valid and can be changed while the view is hidden.</p>
<h3 id="viewsize---w-h-viewsizew-h"><code>view:size() -&gt; w, h</code> <br> <code>view:size(w, h)</code></h3>
<p>Get/set the viewâs size.</p>
<h3 id="viewanchors---anchors-viewanchorsanchors"><code>view:anchors() -&gt; anchors</code> <br> <code>view:anchors(anchors)</code></h3>
<p>Get/set the anchors: they can be any combination of âltrbâ characters representing left, top, right and bottom anchors respectively.</p>
<p>Anchors are a simple but effective way of doing stitched layouting. This is how they work: thereâs four possible anchors which you can set, one for each side of the view. Setting an anchor on one side fixates the distance between that side and the same side of the window the view is on, so that when the window is moved/resized, the view is also moved/resized in order to preserve the initial distance to that side of the window.</p>
<h3 id="viewrect_changedx-y-w-h-viewmovedx-y-viewresizedw-h"><code>view:rect_changed(x, y, w, h)</code> <br> <code>view:moved(x, y)</code> <br> <code>view:resized(w, h)</code></h3>
<p>Event: viewâs size and/or position changed.</p>
<h2 id="mouse">Mouse</h2>
<h3 id="winviewmousevar---val"><code>win/view:mouse(var) -&gt; val</code></h3>
<p>Get the mouse state. The <code>var</code> arg can be: âxâ, âyâ, âposâ, âinsideâ, âleftâ, ârightâ, âmiddleâ, âx1â, âx2â.</p>
<p>The mouse state is not queried: it is the state at the time of the last mouse event. Returns nothing if the window is hidden or minimized.</p>
<p>Mouse coordinates are relative to the windowâs client-area.</p>
<h3 id="winviewmouseenter-winviewmouseleave"><code>win/view:mouseenter()</code> <br> <code>win/view:mouseleave()</code></h3>
<p>Event: mouse entered/left the client area of the window.</p>
<p>These events do not fire while the mouse is captured (see mousedown) but a mouseleave event <em>will</em> fire after mouseup <em>if</em> mouseup happens outside the client area of the window/view that captured the mouse.</p>
<h3 id="winviewmousemovex-y"><code>win/view:mousemove(x, y)</code></h3>
<p>Event: the mouse was moved.</p>
<h3 id="winviewmousedownbutton-x-y-click_count"><code>win/view:mousedown(button, x, y, click_count)</code></h3>
<p>Event: a mouse button was pressed; button can be âleftâ, ârightâ, âmiddleâ, âx1â, âx2â.</p>
<p>While a mouse button is down, the mouse is <em>captured</em> by the window/view which received the mousedown event, which means that the same window/view will continue to receive mousemove events even if the mouse leaves its client area.</p>
<h3 id="winviewmouseupbutton-x-y-click_count"><code>win/view:mouseup(button, x, y, click_count)</code></h3>
<p>Event: a mouse button was depressed.</p>
<h3 id="winviewclickbutton-count-x-y"><code>win/view:click(button, count, x, y)</code></h3>
<p>Event: a mouse button was clicked (fires immediately after mousedown).</p>
<h3 id="repeated-clicks">Repeated clicks</h3>
<h4 id="tldr">TL;DR</h4>
<div class="sourceCode" id="cb2"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">function</span> win<span class="op">:</span>click<span class="op">(</span>button<span class="op">,</span> count<span class="op">,</span> x<span class="op">,</span> y<span class="op">)</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>   <span class="cf">if</span> count <span class="op">==</span> <span class="dv">2</span> <span class="cf">then</span>     <span class="co">--double click</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>      <span class="op">...</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>   <span class="cf">elseif</span> count <span class="op">==</span> <span class="dv">3</span> <span class="cf">then</span> <span class="co">--triple click</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>      <span class="op">...</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>      <span class="cf">return</span> <span class="kw">true</span>         <span class="co">--triple click is as high as we go in this app</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>   <span class="cf">end</span></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="cf">end</span></span></code></pre></div>
<h4 id="how-it-works">How it works</h4>
<p>When the user clicks the mouse repeatedly, with a small enough interval between clicks and over the same target, a counter is incremented. When the interval between two clicks is larger than the threshold or the mouse is moved too far away from the initial target, the counter is reset (i.e.Â the click-chain is interrupted). Returning <code>true</code> on the <code>click()</code> event also resets the counter.</p>
<p>This allows processing of double-clicks, triple-clicks, or multi-clicks by checking the <code>count</code> argument on the <code>click()</code> event. If your app doesnât need to process double-clicks or multi-clicks, you can just ignore the <code>count</code> argument. If it does, you must return <code>true</code> after processing the event with the highest count so that the counter is reset.</p>
<p>For instance, if your app supports double-click over some target, you must return <code>true</code> when count is 2, otherwise you might get a count of 3 on the next click sometimes, instead of 1 as expected. If your app supports both double-click and triple-click over a target, you must return <code>true</code> when the count is 3 to break the click chain, but you must not return anything when the count is 2, or youâll never get a count of 3.</p>
<p>The double-click time interval is from the userâs mouse settings and it is queried on every click.</p>
<h3 id="winviewmousewheeldelta-x-y-pixeldelta-winviewmousehwheeldelta-x-y-pixeldelta"><code>win/view:mousewheel(delta, x, y, pixeldelta)</code> <br> <code>win/view:mousehwheel(delta, x, y, pixeldelta)</code></h3>
<p>Event: the mouse vertical or horizontal wheel was moved. The delta represents the number of lines to scroll.</p>
<p>The number of lines per scroll notch is from the userâs mouse settings and it is queried on every wheel event (Windows, OSX).</p>
<p>The extra <code>pixeldelta</code> arg is given on OSX on devices where analog scrolling is available, in which case that value should be used instead.</p>
<h2 id="rendering">Rendering</h2>
<p>Drawing on a window or view must be done inside the <code>repaint()</code> event by requesting the window/viewâs bitmap or OpenGL context and drawing on it. The OS fires <code>repaint</code> whenever it loses (part of) the contents of the window. To force a repaint anytime, use <code>win:invalidate()</code>.</p>
<p><strong>NOTE:</strong> You canât request a bitmap on an OpenGL-enabled window/view and you canât request an OpenGL context on a non-OpenGL-enabled window/view. To enable OpenGL on a window/view you must pass an <code>opengl</code> options table to the window/view creation function (it can be an empty table or just <code>true</code>).</p>
<h3 id="winviewrepaint"><code>win/view:repaint()</code></h3>
<p>Event: window needs repainting. To repaint the window, simply request the windowâs bitmap or OpenGL context and draw using that.</p>
<h3 id="winviewinvalidateinvalid_clock"><code>win/view:invalidate([invalid_clock])</code></h3>
<p>Request syncâing and repainting. The optional <code>invalid_clock</code> (which defaults to <code>-inf</code>) specifies the earliest <code>time.clock()</code> when the window/view should be repainted (this is useful for implementing delayed animations efficiently).</p>
<h3 id="winviewinvalidat_clock---tf"><code>win/view:invalid([at_clock]) -&gt; t|f</code></h3>
<p>Check if the window/view is invalid at a specific time point (which defaults to <code>time.clock()</code>).</p>
<h3 id="winviewvalidateat_clock"><code>win/view:validate([at_clock])</code></h3>
<p>Fire the <code>sync()</code> event if the window/view is invalid.</p>
<h3 id="winsync"><code>win:sync()</code></h3>
<p>Event: window needs syncâing. This event is fired before <code>repaint()</code>, but only as a result of calling <code>invalidate()</code>.</p>
<p>The point of this function is to separate updating the logical representation of a window or view (i.e.Â its layout) from updating its raster representation (i.e.Â its pixels), so that in some parts of the code you can signal that the layout was put in an inconsistent state and must be syncâed on the next frame, while in other parts of the code you can ask that the layout be syncâed immediately (eg. because you need to hit-test it on a <code>mousemove</code> event), and all this can happen between frames, independent of the repainting cycle.</p>
<h3 id="winviewbitmap---bmp"><code>win/view:bitmap() -&gt; bmp</code></h3>
<p>Get a bgra8 <a href="/bitmap">bitmap</a> object to draw on. The bitmap is freed and replaced when the windowâs client area changes size. The bitmap must be requested inside the <code>repaint()</code> event for drawing purposes, but can also be requested outside the <code>repaint()</code> event for hit-testing purposes.</p>
<p>The alpha channel is not used unless this is a transparent window (note: views cannot be transparent).</p>
<h3 id="bmpclear"><code>bmp:clear()</code></h3>
<p>Fill the bitmap with zeroes.</p>
<h3 id="bmpcairo---cr"><code>bmp:cairo() -&gt; cr</code></h3>
<p>Get a <a href="/cairo">cairo</a> context on the bitmap. The context lasts as long as the bitmap lasts.</p>
<h3 id="winviewfree_cairocr"><code>win/view:free_cairo(cr)</code></h3>
<p>Event: cairo context needs to be freed.</p>
<h3 id="winviewfree_bitmapbmp"><code>win/view:free_bitmap(bmp)</code></h3>
<p>Event: bitmap needs to be freed.</p>
<h3 id="winviewgl---gl"><code>win/view:gl() -&gt; gl</code></h3>
<p>Get an OpenGL context/API to draw on the window or view. For this to work OpenGL must be enabled on the window or view via the <code>opengl</code> options table, which can have the fields:</p>
<ul>
<li><code>profile</code> - OpenGL profile to use: â1.0â, â3.2â (â1.0â)</li>
<li><code>antialiasing</code> - enable antialiasing: âsupersampleâ, âmultisampleâ, true, false (false)</li>
<li><code>samples</code> - number of samples for âmultisampleâ antialiasting (4)</li>
<li><code>vsync</code> - vertical sync: true, false, swap-interval (true)</li>
</ul>
<h2 id="menus">Menus</h2>
<h3 id="appmenu---menu"><code>app:menu() -&gt; menu</code></h3>
<p>Create a menu.</p>
<h3 id="appmenubar---menu"><code>app:menubar() -&gt; menu</code></h3>
<p>Get the appâs menu bar (OSX)</p>
<h3 id="winmenubar---menunil-winmenubarmenunil"><code>win:menubar() -&gt; menu|nil</code> <code>win:menubar(menu|nil)</code></h3>
<p>Get/set/remove the windowâs menu bar (Windows, Linux).</p>
<h3 id="winviewpopupmenu-cx-cy-menupopupwinview-cx-cy"><code>win/view:popup(menu, cx, cy)</code> <br> <code>menu:popup(win/view, cx, cy)</code></h3>
<p>Pop up a menu at a point relative to a window or view.</p>
<h3 id="menuaddindex-text-action-options-menusetindex-text-action-options-menuaddindex-text-action-option-menusetindex-text-action-option"><code>menu:add([index, ]text, [action], [options])</code> <br> <code>menu:set(index, text, [action], [options])</code> <br> <code>menu:add{index =, text =, action =, &lt;option&gt; =}</code> <br> <code>menu:set{index =, text =, action =, &lt;option&gt; =}</code></h3>
<p>Add/set a menu item. The options are:</p>
<ul>
<li><code>action</code> - can be a function or another menu to be used as a submenu</li>
<li><code>text</code> - the text to display:
<ul>
<li><code>&amp;</code> before a letter creates an <em>access key</em></li>
<li><code>\t</code> followed by a key combination creates a <em>shortcut key</em></li>
<li>the empty string (the default) creates a separator</li>
<li>eg. <code>'&amp;Close\tAlt+F4'</code> shows as â<u>C</u>lose Alt+F4â and activates on <code>Alt+C</code> and on <code>Alt+F4</code></li>
</ul></li>
<li><code>submenu</code> - a submenu (same as when <code>action</code> is a submenu)</li>
<li><code>enabled</code> - enabled state (true)</li>
<li><code>checked</code> - checked state (false)</li>
</ul>
<h3 id="menuremoveindex"><code>menu:remove(index)</code></h3>
<p>Remove menu item at index.</p>
<h3 id="menugetindex---item-menugetindex-prop---val"><code>menu:get(index) -&gt; item</code> <br> <code>menu:get(index, prop) -&gt; val</code></h3>
<p>Get a menu item, or the value of one of its properties.</p>
<h3 id="menuitemsprop---item1-...-menuitems---n"><code>menu:items([prop]) -&gt; {item1, ...}</code> <br> <code>menu:items'#' -&gt; n</code></h3>
<p>Get the menu items. If a property name is given, pluck the values of that property from the menu items instead. If â#â is given, get the item count instead.</p>
<h3 id="menucheckedindex---tf-menucheckedindex-tf"><code>menu:checked(index) -&gt; t|f</code> <br> <code>menu:checked(index, t|f)</code></h3>
<p>Get/set the checked state of a menu item.</p>
<h2 id="icons">Icons</h2>
<h3 id="common-api">Common API</h3>
<h3 id="iconfree"><code>icon:free()</code></h3>
<p>Free the icon.</p>
<h3 id="iconbitmap---bmp"><code>icon:bitmap() -&gt; bmp</code></h3>
<p>Get the iconâs bitmap.</p>
<h3 id="iconinvalidate"><code>icon:invalidate()</code></h3>
<p>Request icon redrawing.</p>
<h3 id="iconrepaint"><code>icon:repaint()</code></h3>
<p>Event: icon needs redrawing.</p>
<h3 id="iconfree_bitmapbmp"><code>icon:free_bitmap(bmp)</code></h3>
<p>Event: the iconâs bitmap needs to be freed.</p>
<h3 id="window-icon-windows">Window icon (Windows)</h3>
<h3 id="winiconwhich---icon"><code>win:icon([which]) -&gt; icon</code></h3>
<p>Get the windowâs icon. The <code>which</code> arg can be: âbigâ (default), âsmallâ.</p>
<h3 id="dock-icon-osx">Dock icon (OSX)</h3>
<h3 id="appdockicon---icon"><code>app:dockicon() -&gt; icon</code></h3>
<p>Get the appâs dock icon.</p>
<h3 id="notification-icons-windows-osx">Notification icons (Windows, OSX)</h3>
<h3 id="appnotifyicont---icon"><code>app:notifyicon(t) -&gt; icon</code></h3>
<p>Create a notification icon.</p>
<h3 id="appnotifyicons---icon1-...-appnotifyicons---n"><code>app:notifyicons() -&gt; {icon1, ...}</code> <br> <code>app:notifyicons'#' -&gt; n</code></h3>
<p>Get all the notification icons. If â#â is given, get the icon count instead.</p>
<h3 id="icontooltip---s-icontooltips"><code>icon:tooltip() -&gt; s</code> <br> <code>icon:tooltip(s)</code></h3>
<p>Get/set the iconâs tooltip.</p>
<h3 id="iconmenu---menu-iconmenumenu"><code>icon:menu() -&gt; menu</code> <br> <code>icon:menu(menu)</code></h3>
<p>Get/set a menu for the icon.</p>
<h3 id="icontext---s-icontexts"><code>icon:text() -&gt; s</code> <br> <code>icon:text(s)</code></h3>
<p>Get/set the status bar itemâs text (OSX only).</p>
<h3 id="iconlength---n-iconlengthn"><code>icon:length() -&gt; n</code> <br> <code>icon:length(n)</code></h3>
<p>Get/set the status bar itemâs length (OSX only).</p>
<h2 id="file-choose-dialogs">File choose dialogs</h2>
<h3 id="appopendialogt---pathpath1...nil"><code>app:opendialog(t) -&gt; path|{path1,...}|nil</code></h3>
<p>Open a standard âopen fileâ dialog and wait for it to close. Fields of <em><code>t</code></em>:</p>
<ul>
<li><code>title</code> - dialogâs title</li>
<li><code>filetypes</code> - supported file extensions eg. <code>{'txt', 'jpg', ...}</code></li>
<li><code>multiselect</code> - allow multiple selection (false)</li>
<li><code>initial_dir</code> - initial dir</li>
</ul>
<p>When <code>multiselect = true</code> the dialog returns a list of paths, otherwise it returns a path. If the user closes the dialog without choosing a file, it returns ni.</p>
<h3 id="appsavedialogt---pathnil"><code>app:savedialog(t) -&gt; path|nil</code></h3>
<p>Open a standard âsave fileâ dialog and wait for it to close. Fields of <em><code>t</code></em>:</p>
<ul>
<li><code>title</code> dialogâs title</li>
<li><code>filetypes</code> - supported file extensions eg. <code>{'txt', 'jpg', ...}</code></li>
<li><code>filename</code> - default filename</li>
<li><code>initial_dir</code> - initial dir</li>
</ul>
<p>If the user closes the dialog without choosing a file, it returns ni.</p>
<h2 id="clipboard">Clipboard</h2>
<h3 id="appgetclipboardformat---datanil"><code>app:getclipboard(format) -&gt; data|nil</code></h3>
<p>Get the clipboard contents in one of the available formats. The format can be:</p>
<ul>
<li>âtextâ - returns a string.</li>
<li>âfilesâ - returns <code>{path1, ...}</code></li>
<li>âbitmapâ - returns a <a href="/bitmap">bitmap</a></li>
</ul>
<h3 id="appgetclipboard---formats"><code>app:getclipboard() -&gt; formats</code></h3>
<p>Get the data formats (<code>{format = true}</code>) currently in clipboard.</p>
<h3 id="appsetclipboardfdata-format"><code>app:setclipboard(f|data[, format])</code></h3>
<p>Clear or set the clipboard. Passing <code>false</code> clears it, otherwise <code>data</code> can be:</p>
<ul>
<li>a string (assuming âtextâ format).</li>
<li>a bitmap (assuming âbitmapâ format).</li>
<li>a table <code>{format = ..., data = ...}</code>.</li>
<li>a list of strings (for format: âfilesâ).</li>
</ul>
<h2 id="drag-drop">Drag &amp; Drop</h2>
<h3 id="winviewdropfilesx-y-files"><code>win/view:dropfiles(x, y, files)</code></h3>
<p>Event: files (<code>{filename1, ...}</code>) are dropped over the window/view.</p>
<h3 id="winviewdraggingenter-t-x-y---s-winviewdragginghover-t-x-y---s-winviewdraggingdrop-t-x-y-winviewdraggingleave"><code>win/view:dragging('enter', t, x, y) -&gt; s</code> <br> <code>win/view:dragging('hover', t, x, y) -&gt; s</code> <br> <code>win/view:dragging('drop', t, x, y)</code> <br> <code>win/view:dragging('leave')</code></h3>
<p>Event: something is being dragged over the window/view. The first arg corresponds to the following mouse events:</p>
<ul>
<li>âenterâ - mouse enter</li>
<li>âhoverâ - mouse move</li>
<li>âdropâ - mouse button up</li>
<li>âleaveâ - mouse leave</li>
</ul>
<p>The <code>t</code> arg is a table cotaining the drag payload in one or more formats: <code>{format = data}</code>. The <code>x</code>, <code>y</code> args are the mouse coordinates in window/view client space.</p>
<p>You can respond to the âenterâ and âhoverâ stages by returning:</p>
<ul>
<li>âcopyâ - show a cursor indicating that the data is being copied</li>
<li>âlinkâ - show a cursor indicating that the data is being linked</li>
<li>ânoneâ - show the normal arrow cursor</li>
<li>âabortâ - show the forbidden icon</li>
<li>true - means âcopyâ</li>
<li>false - means âabortâ</li>
<li>nil/nothing - means âabortâ</li>
</ul>
<h2 id="tooltips">Tooltips</h2>
<h3 id="wintooltiptext-wintooltipfalse-wintooltip---textfalse"><code>win:tooltip(text)</code> <br> <code>win:tooltip(false)</code> <br> <code>win:tooltip() -&gt; text|false</code></h3>
<p>Get/set/hide windowâs tooltip.</p>
<h2 id="events">Events</h2>
<p>nw uses the <a href="/events">events</a> mixin to add events functionality to all <code>app</code>, <code>win</code> and <code>view</code> objects. This means that:</p>
<ul>
<li>you can add methods to these objects named after the event and they will be called automatically when the event fires.</li>
<li><code>:on()</code>, <code>:off()</code> and <code>:fire()</code> methods are available on these objects and can be used for custom events too.</li>
</ul>
<h3 id="appwinvieweventsenabled---prev_state"><code>app/win/view:events(enabled) -&gt; prev_state</code></h3>
<p>Enable/disable events.</p>
<h2 id="version-checks">Version checks</h2>
<h3 id="appverquery---tf"><code>app:ver(query) -&gt; t|f</code></h3>
<p>Check that a certain backend API is at a specified version or beyond. The query has the form <code>'&lt;API&gt; &lt;version&gt;'</code> where API can be âWindowsâ, âOSXâ or âXâ.</p>
<p>Example: <code>app:ver'OSX 10.8'</code> returns <code>true</code> on OSX 10.8 and beyond.</p>
<p>For Windows you can use the following table to figure it out:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Release</th>
<th style="text-align: left;">Version</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Windows 10</td>
<td style="text-align: left;">10.0 (6.2)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Windows Server 2016 TP</td>
<td style="text-align: left;">10.0 (6.2)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Windows 8.1</td>
<td style="text-align: left;">6.3 (6.2)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Windows Server 2012 R2</td>
<td style="text-align: left;">6.3 (6.2)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Windows 8</td>
<td style="text-align: left;">6.2</td>
</tr>
<tr class="even">
<td style="text-align: left;">Windows Server 2012</td>
<td style="text-align: left;">6.2</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Windows 7</td>
<td style="text-align: left;">6.1</td>
</tr>
<tr class="even">
<td style="text-align: left;">Windows Server 2008 R2</td>
<td style="text-align: left;">6.1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Windows Server 2008</td>
<td style="text-align: left;">6.0</td>
</tr>
<tr class="even">
<td style="text-align: left;">Windows Vista</td>
<td style="text-align: left;">6.0</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Windows Server 2003 R2</td>
<td style="text-align: left;">5.2</td>
</tr>
<tr class="even">
<td style="text-align: left;">Windows Server 2003</td>
<td style="text-align: left;">5.2</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Windows XP 64-Bit Edition</td>
<td style="text-align: left;">5.2</td>
</tr>
<tr class="even">
<td style="text-align: left;">Windows XP</td>
<td style="text-align: left;">5.1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Windows 2000</td>
<td style="text-align: left;">5.0</td>
</tr>
</tbody>
</table>
<p><strong>NOTE:</strong> Apps not manifested for Windows 8.1 or Windows 10 will report platforms greater than 6.2 as 6.2 (the <a href="/luajit">luajit</a> package comes with proper manifest files).</p>
<h2 id="common-mistakes">Common mistakes</h2>
<h3 id="assuming-that-calls-are-blocking">Assuming that calls are blocking</h3>
<p>The number one mistake you can make is to assume that all calls are blocking. Itâs very easy to make that mistake because some of them actually are blocking on some platforms (in order of sanity: Windows, OSX and Linux â X11 is particularly bad because <em>all</em> calls are asynchronous there). In a perfect world they would all be blocking and non-failing which would make programming with them much more robust and intuitive. The real world is an unspecified mess. So <strong>never, ever mix queries with commands</strong>, i.e.Â never assume that after a state-changing function returns you can make any assumptions about the state of the objects involved.</p>
<h3 id="assuming-that-events-fire-in-a-specific-order">Assuming that events fire in a specific order</h3>
<p>Do not assume that events fire in a specific order. Even if they appear to do so on one platform, that may not hold true on another platform. For instance, do not assume that app the activation event fires before the window activation event or that one should cause the other to fire.</p>
<h3 id="creating-windows-in-visible-state">Creating windows in visible state</h3>
<p>The <code>visible</code> flag when creating windows defaults to <code>true</code>, but you should really create windows with <code>visible = false</code>, set up all the event handlers on them and then call <code>win:show()</code>, otherwise you will not catch any events that trigger before you set up the event handlers (sometimes that includes the <code>repaint()</code> event so you will be showing a non-painted window).</p>
<h3 id="hitting-undefined-behavior">Hitting undefined behavior</h3>
<p>One of the goals of this library is to reduce undefined behavior, but there will always be corner cases that are not covered. If your app behaves differently when ported to another platform, please file up a bug report. Even for contradictory situations (like seetting a minimum size constraint that is larger than the maxium size constraint) there should be a single answer for all platforms, even if that answer is arbitrary.</p>
<h2 id="getting-involved">Getting Involved</h2>
<p>This is one of the bigger bricks of luapower but it is one which lends itself well to community development. The frontend uses composition rather than inheritance to connect to the backend so the communication between the two is always explicit. Features are well separated functionally and visually in the code so they can be developed separately without much risk of regressions. The code is well commented and thereâs unit tests and interactive tests which cover most of the functionality. The code follows the luapower <a href="/coding-style">coding-style</a> and <a href="/api-design">api-design</a> guidelines.</p>
<h3 id="development-process">Development process</h3>
<p>All the development planning, coordination and communication is done via github issues and milestones.</p>
<h3 id="design-goals">Design Goals</h3>
<ul>
<li>level out platform differences for common functionality.</li>
<li><em>do</em> support platform idioms and platform-specific functionality.</li>
<li>minimize the need for emulation of missing features by rethinking the API.</li>
<li>take preventive measures to avoid platform behavior:
<ul>
<li>raise errors for parameter combinations that are not universally supported.</li>
<li>clamp values to universally supported ranges.</li>
<li>make stable iterators with specified order or better yet, return arrays.</li>
</ul></li>
<li>seek orthogonality, but do add convenience methods where useful.</li>
</ul>
