<h2 id="what-lua-dialiect-is-this">What Lua dialiect is this?</h2>
<p>This is OpenResty’s LuaJIT 2.1 fork, which means the base language is <a href="http://www.lua.org/manual/5.1/manual.html">Lua 5.1</a> plus the following extensions:</p>
<ul>
<li><a href="http://luajit.org/extensions.html#modules">LuaJIT’s bit, ffi and jit modules</a></li>
<li><a href="http://luajit.org/extensions.html#lua52">LuaJIT’s extensions from Lua 5.2</a>, including those enabled with <code>DLUAJIT_ENABLE_LUA52COMPAT</code></li>
<li><a href="https://github.com/openresty/luajit2#openresty-extensions">OpenResty’s extensions</a></li>
<li><code>package.exedir</code> module which returns the full path of the directory of the executable.</li>
<li><code>package.exepath</code> module which returns the full path of the executable.</li>
<li><code>LUA_PATH</code> and <code>LUA_CPATH</code> supports <code>'!'</code> in Linux and OSX too.</li>
<li><code>LUA_CPATH_DEFAULT</code> and <code>LUA_PATH_DEFAULT</code> were modified as described below.</li>
<li>the <code>terra</code> module is loaded when running <code>.t</code> files from the command line.</li>
<li><code>SONAME</code> is not set in <code>libluajit.so</code>.</li>
</ul>
<h2 id="what-is-included">What is included</h2>
<p>LuaJIT binaries (frontend, static library, dynamic library).</p>
<p>Comes bundled with the <code>luajit</code> command, which is a simple shell script that finds and loads the appropriate luajit executable for your platform/arch so that typing <code>./luajit</code> (that’s <code>luajit</code> on Windows) always works.</p>
<p>LuaJIT was compiled using its original makefile.</p>
<h2 id="making-portable-apps">Making portable apps</h2>
<p>To make a portable app that can run from any directory out of the box, every subsystem of the app that needs to open a file must look for that file in a location relative to the app’s directory. This means at least three things:</p>
<ul>
<li>Lua’s require() must look in exe-relative dirs first,</li>
<li>the OS’s shared library loader must look in exe-relative dirs first,</li>
<li>the app itself must look for assets, config files, etc. in exe-relative dirs first.</li>
</ul>
<p>The solutions for the first two problems are platform-specific and are described below. As for the third problem, you can extract the exe’s path from <code>arg[-1]</code> or use the more reliable <a href="fs#fs.exedir">fs.exedir</a>. To get the location of the <em>running script</em>, as opposed to that of the executable, use <a href="glue#glue.bin">glue.bin</a>. To add more paths to package.path and package.cpath at runtime, use <a href="glue#glue.luapath">glue.luapath</a> and <a href="glue#glue.cpath">glue.cpath</a> respectively.</p>
<h3 id="finding-lua-modules">Finding Lua modules</h3>
<p><code>!\..\..\?.lua;!\..\..\?\init.lua</code> was added to the default <code>package.path</code> in <code>luaconf.h</code>. This allows luapower modules to be found regardless of what the current directory is, making the distribution portable.</p>
<p>The default <code>package.cpath</code> was also modified from <code>!\?.dll</code> to <code>!\clib\?.dll</code>. This is to distinguish between Lua/C modules and other binary dependencies and avoid name clashes on Windows where shared libraries are not prefixed with <code>lib</code>.</p>
<p>The <code>!</code> symbol was implemented for Linux and OSX too.</p>
<h4 id="the-current-directory">The current directory</h4>
<p>Lua modules (including Lua/C modules) are searched for in the current directory <strong><em>first</em></strong> (on any platform), so the isolation from the host system is not absolute.</p>
<p>This is the Lua’s default setting and although it’s arguably a security risk, it’s convenient for when you want to have a single luapower tree, possibly added to the system PATH, to be shared between many apps. In this case, starting luajit in the directory of the app makes the app’s modules accessible automatically.</p>
<h3 id="finding-shared-libraries">Finding shared libraries</h3>
<h4 id="windows">Windows</h4>
<p>Windows looks for dlls in the directory of the executable first by default, and that’s where the luapower dlls are, so isolation from system libraries is acheived automatically in this case.</p>
<h4 id="linux">Linux</h4>
<p>Linux binaries are built with <code>rpath=$ORIGIN</code> which makes ldd look for shared objects in the directory of the exe first.</p>
<p><code>-Wl,--disable-new-dtags</code> was also used so that it’s <code>RPATH</code> not <code>RUNPATH</code> that is being set, which makes <code>dlopen()</code> work the same from dynamically loaded code too (this enables eg. <code>terralib.linklibrary</code> to link against luapower libraries by name alone). I’m biting my tongue so hard here…</p>
<h4 id="osx">OSX</h4>
<p>OSX binaries are built with <code>rpath=@loader_path</code> which makes the dynamic loader look for dylibs in the directory of the exe first.</p>
<h4 id="the-current-directory-1">The current directory</h4>
<p>The current directory is <em>not used</em> for finding shared libraries on Linux and OSX. It’s only used on Windows, but has lower priority than the exe’s directory.</p>
<h3 id="finding-terra-modules">Finding <a href="/terra">terra</a> modules</h3>
<p>The luajit executable was modified to call <code>require'terra'</code> before trying to run <code>.t</code> files at the command line. Also, it loads <code>.t</code> files by calling <code>_G.loadfile</code> instead of the C function <code>lua_loadfile</code>.</p>
<p><code>_G.loadfile</code> is overriden in <code>terralib_luapower.lua</code> to load <code>.t</code> files as Terra source code.</p>
<p><code>terralib.lua</code> was changed to load <code>terralib_luapower.lua</code> at the end of the file.</p>
<p><code>package.terrapath</code> is set to match <code>package.path</code> in <code>terralib_luapower.lua</code>.</p>
