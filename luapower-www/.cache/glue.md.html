<h2 id="local-glue-requireglue"><code>local glue = require'glue'</code></h2>
<h2 id="api-summary">API Summary</h2>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>math</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>glue.round(x[, p]) -&gt; y</code></td>
<td>round x to nearest integer or multiple of <code>p</code> (half up)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.snap(x[, p]) -&gt; y</code></td>
<td>synonym for glue.round</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>glue.floor(x[, p]) -&gt; y</code></td>
<td>round x down to nearest integer or multiple of <code>p</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.ceil(x[, p]) -&gt; y</code></td>
<td>round x up to nearest integer or multiple of <code>p</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>glue.clamp(x, min, max) -&gt; y</code></td>
<td>clamp x in range</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.lerp(x, x0, x1, y0, y1) -&gt; y</code></td>
<td>linear interpolation</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>glue.nextpow2(x) -&gt; y</code></td>
<td>next power-of-2 number</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>varargs</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>glue.pack(...) -&gt; t</code></td>
<td>pack varargs</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.unpack(t, [i] [,j]) -&gt; ...</code></td>
<td>unpack varargs</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>tables</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.count(t) -&gt; n</code></td>
<td>number of keys in table</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>glue.index(t) -&gt; dt</code></td>
<td>switch keys with values</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.keys(t[,sorted|cmp]) -&gt; dt</code></td>
<td>make a list of all the keys</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>glue.sortedpairs(t [,cmp]) -&gt; iter() -&gt; k, v</code></td>
<td>like pairs() but in key order</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.update(dt, t1, ...) -&gt; dt</code></td>
<td>merge tables - overwrites keys</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>glue.merge(dt, t1, ...) -&gt; dt</code></td>
<td>merge tables - no overwriting</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.attr(t, k1 [,v])[k2] = v</code></td>
<td>autofield pattern</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>lists</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.extend(dt, t1, ...) -&gt; dt</code></td>
<td>extend a list</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>glue.append(dt, v1, ...) -&gt; dt</code></td>
<td>append non-nil values to a list</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.shift(t, i, n) -&gt; t</code></td>
<td>shift list elements</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>glue.map(t, field|f,...) -&gt; t</code></td>
<td>map f over t or select a column from a list of records</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>arrays</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>glue.indexof(v, t, [i], [j]) -&gt; i</code></td>
<td>scan array for value</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.binsearch(v, t, [cmp], [i], [j]) -&gt; i</code></td>
<td>binary search in sorted list</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>glue.reverse(t, [i], [j]) -&gt; t</code></td>
<td>reverse list in place</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>strings</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>glue.gsplit(s,sep[,start[,plain]]) -&gt; iter() -&gt; e[,captures...]</code></td>
<td>split a string by a pattern</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.lines(s[, opt]) -&gt; iter() -&gt; s</code></td>
<td>iterate the lines of a string</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>glue.trim(s) -&gt; s</code></td>
<td>remove padding</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.esc(s [,mode]) -&gt; pat</code></td>
<td>escape magic pattern characters</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>glue.tohex(s|n [,upper]) -&gt; s</code></td>
<td>string to hex</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.fromhex(s) -&gt; s</code></td>
<td>hex to string</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>glue.starts(s, prefix) -&gt; t|f</code></td>
<td>find if string <code>s</code> starts with string <code>prefix</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.ends(s, suffix) -&gt; t|f</code></td>
<td>find if string <code>s</code> ends with string <code>suffix</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>iterators</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.collect([i,] iterator) -&gt; t</code></td>
<td>collect iterated values into a list</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>closures</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.pass(...) -&gt; ...</code></td>
<td>does nothing, returns back all arguments</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>glue.noop(...)</code></td>
<td>does nothing, returns nothing</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.memoize(f[, narg]) -&gt; f</code></td>
<td>memoize pattern</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>glue.memoize_multiret(f[, narg]) -&gt; f</code></td>
<td>memoize for multiple-return-value functions</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.tuples([narg]) -&gt; f(...) -&gt; t</code></td>
<td>tuple pattern</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>objects</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.inherit(t, parent) -&gt; t</code></td>
<td>set or clear inheritance</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>glue.object([super][, t], ...) -&gt; t</code></td>
<td>create a class or object (see description)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.before(class, method_name, f)</code></td>
<td>call f at the beginning of a method</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>glue.after(class, method_name, f)</code></td>
<td>call f at the end of a method</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.override(class, method_name, f)</code></td>
<td>override a method</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>i/o</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.canopen(filename[, mode]) -&gt; filename | nil</code></td>
<td>check if a file exists and can be opened</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>glue.readfile(filename[, format][, open]) -&gt; s | nil, err</code></td>
<td>read the contents of a file into a string</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.readpipe(cmd[,format][, open]) -&gt; s | nil, err</code></td>
<td>read the output of a command into a string</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>glue.writefile(filename, s|t|read, [format], [tmpfile])</code></td>
<td>write data to file safely</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.printer(out[, format]) -&gt; f</code></td>
<td>virtualize the print() function</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>time</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.time([t, [utc]]) -&gt; timestamp</code></td>
<td>like <code>os.time()</code> but can do UTC</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>errors</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.assert(v [,message [,format_args...]]) -&gt; v</code></td>
<td>assert with error message formatting</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>glue.protect(func) -&gt; protected_func</code></td>
<td>wrap an error-raising function</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.pcall(f, ...) -&gt; true, ... | false, traceback</code></td>
<td>pcall with traceback</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>glue.fpcall(f, ...) -&gt; result | nil, traceback</code></td>
<td>coding with finally and except</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.fcall(f, ...) -&gt; result</code></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>modules</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.module([name, ][parent]) -&gt; M</code></td>
<td>create a module</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>glue.autoload(t, submodules) -&gt; M</code></td>
<td>autoload table keys from submodules</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.autoload(t, key, module|loader) -&gt; t</code></td>
<td>autoload table keys from submodules</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>glue.bin</code></td>
<td>get the script’s directory</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.luapath(path [,index [,ext]])</code></td>
<td>insert a path in package.path</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>glue.cpath(path [,index])</code></td>
<td>insert a path in package.cpath</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>allocation</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>glue.freelist([create], [destroy]) -&gt; alloc, free</code></td>
<td>freelist allocation pattern</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.buffer(ctype) -&gt; alloc(minlen) -&gt; buf,capacity</code></td>
<td>auto-growing buffer</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>ffi</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.addr(ptr) -&gt; number | string</code></td>
<td>store pointer address in Lua value</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>glue.ptr([ctype, ]number|string) -&gt; ptr</code></td>
<td>convert address to pointer</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>glue.getbit(val, mask) -&gt; true|false</code></td>
<td>get the value of a single bit from an integer</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>glue.setbit(val, mask, bitval)</code></td>
<td>set the value of a single bit from an integer</td>
</tr>
</tbody>
</table>
<h2 id="math">Math</h2>
<h3 id="glue.roundx-p---y-glue.snapx-p---y"><code>glue.round(x[, p]) -&gt; y</code> <br> <code>glue.snap(x[, p]) -&gt; y</code></h3>
<p>Round a number towards nearest integer or multiple of <code>p</code>. Implemented as <code>math.floor(x / p + .5) * p</code>. Rounds half-up (i.e. it returns <code>-1</code> for <code>-1.5</code>). Works with numbers up to <code>+/-2^52</code>. It’s not dead accurate as it returns eg. <code>1</code> instead of <code>0</code> for <code>0.49999999999999997</code> (the number right before <code>0.5</code>) which is &lt; <code>0.5</code>.</p>
<h2 id="glue.floorx-p---y"><code>glue.floor(x[, p]) -&gt; y</code></h2>
<p>Round a number towards nearest smaller integer or multiple of <code>p</code>. Implemented as <code>math.floor(x / p) * p</code>.</p>
<h2 id="glue.ceilx-p---y"><code>glue.ceil(x[, p]) -&gt; y</code></h2>
<p>Round a number towards nearest larger integer or multiple of <code>p</code>. Implemented as <code>math.ceil(x / p) * p</code>.</p>
<h3 id="glue.clampx-min-max"><code>glue.clamp(x, min, max)</code></h3>
<p>Clamp a value in range. Implemented as <code>math.min(math.max(x, min), max)</code>, so if <code>max &lt; min</code>, the result is <code>max</code>.</p>
<h3 id="glue.lerpx-x0-x1-y0-y1---y"><code>glue.lerp(x, x0, x1, y0, y1) -&gt; y</code></h3>
<p>Linear interpolation, i.e. linearly project <code>x</code> in <code>x0..x1</code> range to the <code>y0..y1</code> range.</p>
<h3 id="glue.nextpow2x---y"><code>glue.nextpow2(x) -&gt; y</code></h3>
<p>Find the smallest <code>n</code> for which <code>x &lt;= 2^n</code>.</p>
<hr />
<h2 id="varargs">Varargs</h2>
<h3 id="glue.pack...---t"><code>glue.pack(...) -&gt; t</code></h3>
<p>Pack varargs. Implemented as <code>n = select('#', ...), ...}</code>.</p>
<h3 id="glue.unpacktij---..."><code>glue.unpack(t,[i][,j]) -&gt; ...</code></h3>
<p>Unpack varargs. Implemented as <code>unpack(t, i or 1, j or t.n or #t)</code>.</p>
<hr />
<h2 id="tables">Tables</h2>
<h3 id="glue.countt---n"><code>glue.count(t) -&gt; n</code></h3>
<p>Count all the keys in a table.</p>
<hr />
<h3 id="glue.indext---dt"><code>glue.index(t) -&gt; dt</code></h3>
<p>Switch table keys with values.</p>
<h4 id="examples">Examples</h4>
<p>Extract a rfc850 date from a string. Use lookup tables for weekdays and months.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">local</span> weekdays <span class="op">=</span> glue<span class="op">.</span>index<span class="op">{</span><span class="st">&#39;Sunday&#39;</span><span class="op">,</span> <span class="st">&#39;Monday&#39;</span><span class="op">,</span> <span class="st">&#39;Tuesday&#39;</span><span class="op">,</span> <span class="st">&#39;Wednesday&#39;</span><span class="op">,</span> <span class="st">&#39;Thursday&#39;</span><span class="op">,</span> <span class="st">&#39;Friday&#39;</span><span class="op">,</span> <span class="st">&#39;Saturday&#39;</span><span class="op">}</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">local</span> months <span class="op">=</span> glue<span class="op">.</span>index<span class="op">{</span><span class="st">&#39;Jan&#39;</span><span class="op">,</span> <span class="st">&#39;Feb&#39;</span><span class="op">,</span> <span class="st">&#39;Mar&#39;</span><span class="op">,</span> <span class="st">&#39;Apr&#39;</span><span class="op">,</span> <span class="st">&#39;May&#39;</span><span class="op">,</span> <span class="st">&#39;Jun&#39;</span><span class="op">,</span> <span class="st">&#39;Jul&#39;</span><span class="op">,</span> <span class="st">&#39;Aug&#39;</span><span class="op">,</span> <span class="st">&#39;Sep&#39;</span><span class="op">,</span> <span class="st">&#39;Oct&#39;</span><span class="op">,</span> <span class="st">&#39;Nov&#39;</span><span class="op">,</span> <span class="st">&#39;Dec&#39;</span><span class="op">}</span></span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="co">--weekday &quot;,&quot; SP 2DIGIT &quot;-&quot; month &quot;-&quot; 2DIGIT SP 2DIGIT &quot;:&quot; 2DIGIT &quot;:&quot; 2DIGIT SP &quot;GMT&quot;</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="co">--eg. Sunday, 06-Nov-94 08:49:37 GMT</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="kw">function</span> rfc850date<span class="op">(</span>s<span class="op">)</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>   <span class="kw">local</span> w<span class="op">,</span>d<span class="op">,</span>mo<span class="op">,</span>y<span class="op">,</span>h<span class="op">,</span>m<span class="op">,</span>s <span class="op">=</span> s<span class="op">:</span><span class="fu">match</span><span class="st">&#39;([A-Za-z]+), (%d+)%-([A-Za-z]+)%-(%d+) (%d+):(%d+):(%d+) GMT&#39;</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>   d<span class="op">,</span>y<span class="op">,</span>h<span class="op">,</span>m<span class="op">,</span>s <span class="op">=</span> <span class="fu">tonumber</span><span class="op">(</span>d<span class="op">),</span><span class="fu">tonumber</span><span class="op">(</span>y<span class="op">),</span><span class="fu">tonumber</span><span class="op">(</span>h<span class="op">),</span><span class="fu">tonumber</span><span class="op">(</span>m<span class="op">),</span><span class="fu">tonumber</span><span class="op">(</span>s<span class="op">)</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>   w <span class="op">=</span> <span class="fu">assert</span><span class="op">(</span>weekdays<span class="op">[</span>w<span class="op">])</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>   mo <span class="op">=</span> <span class="fu">assert</span><span class="op">(</span>months<span class="op">[</span>mo<span class="op">])</span></span>
<span id="cb1-11"><a href="#cb1-11"></a>   <span class="cf">if</span> y <span class="cf">then</span> y <span class="op">=</span> y <span class="op">+</span> <span class="op">(</span>y <span class="op">&gt;</span> <span class="dv">50</span> <span class="kw">and</span> <span class="dv">1900</span> <span class="kw">or</span> <span class="dv">2000</span><span class="op">)</span> <span class="cf">end</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>   <span class="cf">return</span> <span class="op">{</span>wday <span class="op">=</span> w<span class="op">,</span> day <span class="op">=</span> d<span class="op">,</span> year <span class="op">=</span> y<span class="op">,</span> month <span class="op">=</span> mo<span class="op">,</span> hour <span class="op">=</span> h<span class="op">,</span> min <span class="op">=</span> m<span class="op">,</span> sec <span class="op">=</span> s<span class="op">}</span></span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="cf">end</span></span>
<span id="cb1-14"><a href="#cb1-14"></a></span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="cf">for</span> k<span class="op">,</span>v <span class="kw">in</span> <span class="fu">pairs</span><span class="op">(</span>rfc850date<span class="st">&#39;Sunday, 06-Nov-94 08:49:37 GMT&#39;</span><span class="op">)</span> <span class="cf">do</span></span>
<span id="cb1-16"><a href="#cb1-16"></a>   <span class="fu">print</span><span class="op">(</span>k<span class="op">,</span>v<span class="op">)</span></span>
<span id="cb1-17"><a href="#cb1-17"></a><span class="cf">end</span></span></code></pre></div>
<p>Output</p>
<pre><code>day   6
sec   37
wday  1
min   49
year  1994
month 11
hour  8</code></pre>
<p>Copy-paste a bunch of defines from a C header file and create an inverse lookup table to find the name of a value at runtime.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb3-1"><a href="#cb3-1"></a><span class="co">--from ibase.h</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>info_end_codes <span class="op">=</span> <span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>   isc_info_end             <span class="op">=</span> <span class="dv">1</span><span class="op">,</span>  <span class="co">--normal ending</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>   isc_info_truncated       <span class="op">=</span> <span class="dv">2</span><span class="op">,</span>  <span class="co">--receiving buffer too small</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>   isc_info_error           <span class="op">=</span> <span class="dv">3</span><span class="op">,</span>  <span class="co">--error, check status vector</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>   isc_info_data_not_ready  <span class="op">=</span> <span class="dv">4</span><span class="op">,</span>  <span class="co">--data not available for some reason</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>   isc_info_svc_timeout     <span class="op">=</span> <span class="dv">64</span><span class="op">,</span> <span class="co">--timeout expired</span></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="op">}</span></span>
<span id="cb3-9"><a href="#cb3-9"></a>info_end_code_names <span class="op">=</span> glue<span class="op">.</span>index<span class="op">(</span>info_end_codes<span class="op">)</span></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="fu">print</span><span class="op">(</span>info_end_code_names<span class="op">[</span><span class="dv">64</span><span class="op">])</span></span></code></pre></div>
<p>Output</p>
<pre><code>isc_info_svc_timeout</code></pre>
<hr />
<h3 id="glue.keystsortedcmp---dt"><code>glue.keys(t[,sorted|cmp]) -&gt; dt</code></h3>
<p>Make a list of all the keys of <code>t</code>, optionally sorted. The second arg can be <code>true</code>, <code>'asc'</code>, <code>'desc'</code> or a comparison function.</p>
<h4 id="examples-1">Examples</h4>
<p>An API expects a list of things but you have them as keys in a table because you are indexing something on them.</p>
<p>For instance, you have a table of the form <code>{socket = thread}</code> but <code>socket.select</code> wants a list of sockets.</p>
<hr />
<h3 id="glue.sortedpairstcmp---iter---kv"><code>glue.sortedpairs(t[,cmp]) -&gt; iter() -&gt; k,v</code></h3>
<p>Like pairs() but in key order.</p>
<p>The implementation creates a temporary table to sort the keys in.</p>
<hr />
<h3 id="glue.updatedtt1...---dt"><code>glue.update(dt,t1,...) -&gt; dt</code></h3>
<p>Update a table with elements of other tables, overwriting any existing keys.</p>
<ul>
<li>falsey arguments are skipped.</li>
</ul>
<h4 id="examples-2">Examples</h4>
<p>Create an options table by merging the options received as an argument (if any) over the default options.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">function</span> f<span class="op">(</span>opts<span class="op">)</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>   opts <span class="op">=</span> glue<span class="op">.</span>update<span class="op">({},</span> default_opts<span class="op">,</span> opts<span class="op">)</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="cf">end</span></span></code></pre></div>
<p>Shallow table copy:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb6-1"><a href="#cb6-1"></a>t <span class="op">=</span> glue<span class="op">.</span>update<span class="op">({},</span> t<span class="op">)</span></span></code></pre></div>
<p>Static multiple inheritance:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb7-1"><a href="#cb7-1"></a><span class="cn">C</span> <span class="op">=</span> glue<span class="op">.</span>update<span class="op">({},</span> <span class="cn">A</span><span class="op">,</span> <span class="cn">B</span><span class="op">)</span></span></code></pre></div>
<hr />
<h3 id="glue.mergedtt1...---dt"><code>glue.merge(dt,t1,...) -&gt; dt</code></h3>
<p>Update a table with elements of other tables skipping on any existing keys.</p>
<ul>
<li>falsey arguments are skipped.</li>
</ul>
<h4 id="examples-3">Examples</h4>
<p>Normalize a data object with default values:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb8-1"><a href="#cb8-1"></a>glue<span class="op">.</span>merge<span class="op">(</span>t<span class="op">,</span> defaults<span class="op">)</span></span></code></pre></div>
<hr />
<h3 id="glue.attrtk1vk2-v"><code>glue.attr(t,k1[,v])[k2] = v</code></h3>
<p>Idiom for <code>t[k1][k2] = v</code> with auto-creating of <code>t[k1]</code> if not present.</p>
<hr />
<h2 id="lists">Lists</h2>
<h3 id="glue.extenddtt1...---dt"><code>glue.extend(dt,t1,...) -&gt; dt</code></h3>
<p>Extend the list with the elements of other lists.</p>
<ul>
<li>falsey arguments are skipped.</li>
<li>list elements are the ones from 1 to <code>#dt</code>.</li>
</ul>
<h4 id="uses">Uses</h4>
<p>Accumulating values from multiple list sources.</p>
<hr />
<h3 id="glue.appenddtv1...---dt"><code>glue.append(dt,v1,...) -&gt; dt</code></h3>
<p>Append non-nil arguments to a list.</p>
<h4 id="uses-1">Uses</h4>
<p>Appending an object to a flattened list of lists (eg. appending a path element to a 2d path).</p>
<hr />
<h3 id="glue.shifttin---t"><code>glue.shift(t,i,n) -&gt; t</code></h3>
<p>Shift all the list elements starting at index <code>i</code>, <code>n</code> positions to the left or further to the right.</p>
<p>For a positive <code>n</code>, shift the elements further to the right, effectively creating room for <code>n</code> new elements at index <code>i</code>. When <code>n</code> is 1, the effect is the same as for <code>table.insert(t, i, t[i])</code>. The old values at index <code>i</code> to <code>i+n-1</code> are preserved, so <code>#t</code> still works after the shifting.</p>
<p>For a negative <code>n</code>, shift the elements to the left, effectively removing <code>n</code> elements at index <code>i</code>. When <code>n</code> is -1, the effect is the same as for <code>table.remove(t, i)</code>.</p>
<h4 id="uses-2">Uses</h4>
<p>Removing a portion of a list or making room for more elements inside the list.</p>
<hr />
<h3 id="glue.mapt-fieldf...---t"><code>glue.map(t, field|f,...) -&gt; t</code></h3>
<p>Map function <code>f(v, ...) -&gt; v1</code> over the array elements of <code>t</code> or, if the array part is empty, map <code>f(k, v, ...) -&gt; v1</code> over the pairs of <code>t</code>.</p>
<p>If <code>f</code> is not a function, then the values of <code>t</code> must be themselves tables, in which case <code>f</code> is a key to pluck from those tables. Plucked functions are called as methods and their result is selected instead (this allows eg. calling a method for each element in a list or map of objects and collecting the results in a list/map).</p>
<hr />
<h2 id="arrays">Arrays</h2>
<h3 id="glue.indexofv-t-i-j---i"><code>glue.indexof(v, t, [i], [j]) -&gt; i</code></h3>
<p>Scan an array for a value and if found, return the index.</p>
<p><strong>NOTE:</strong> Works on ffi arrays too if <code>i</code> and <code>j</code> are provided.</p>
<hr />
<h3 id="glue.binsearchv-t-cmp-i-j---i"><code>glue.binsearch(v, t, [cmp], [i], [j]) -&gt; i</code></h3>
<p>Return the smallest index whereby inserting the value <code>v</code> in sorted list <code>t</code> will keep <code>t</code> sorted i.e. <code>t[i-1] &lt; v</code> and <code>t[i] &gt;= v</code>. Return <code>nil</code> if <code>v</code> is larger than the largest value or if <code>t</code> is empty.</p>
<p>The comparison function <code>cmp</code> is called as <code>cmp(t, i, v)</code> and must return <code>true</code> when <code>t[i] &lt; v</code>. Built-in functions are also available by passing one of <code>'&lt;'</code>, <code>'&gt;'</code>, <code>'&lt;='</code>, <code>'&gt;='</code>.</p>
<p><strong>TIP:</strong> Use a <code>cmp</code> that returns <code>true</code> when <code>t[i] &gt; v</code> to search in a reverse-sorted list (i.e. use <code>'&gt;'</code>).</p>
<p><strong>TIP:</strong> Use a <code>cmp</code> that returns <code>true</code> when <code>t[i] &lt;= v</code> to get the <em>largest</em> index (as opposed to the <em>smallest</em> index) that will keep <code>t</code> sorted when inserting <code>v</code>, i.e. <code>t[i-1] &lt;= v</code> and <code>t[i] &gt; v</code>.</p>
<p><strong>NOTE:</strong> Works on ffi arrays too if <code>i</code> and <code>j</code> are provided.</p>
<hr />
<h3 id="glue.reverset-i-j---t"><code>glue.reverse(t, [i], [j]) -&gt; t</code></h3>
<p>Reverse a list in-place and return the input arg.</p>
<p><strong>NOTE:</strong> Works on ffi arrays too if <code>i</code> and <code>j</code> are provided.</p>
<hr />
<h2 id="strings">Strings</h2>
<h3 id="glue.gsplitssepstartplain---iter---ecaptures..."><code>glue.gsplit(s,sep[,start[,plain]]) -&gt; iter() -&gt; e[,captures...]</code></h3>
<p>Split a string by a separator pattern (or plain string) and iterate over the elements.</p>
<ul>
<li>if sep is "" return the entire string in one iteration</li>
<li>if s is "" return s in one iteration</li>
<li>empty strings between separators are always returned, eg. <code>glue.gsplit(',', ',')</code> produces 2 empty strings</li>
<li>captures are allowed in sep and they are returned after the element, except for the last element for which they don’t match (by definition).</li>
</ul>
<h4 id="examples-4">Examples</h4>
<div class="sourceCode" id="cb9"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb9-1"><a href="#cb9-1"></a><span class="cf">for</span> s <span class="kw">in</span> glue<span class="op">.</span>gsplit<span class="op">(</span><span class="st">&#39;Spam eggs spam spam and ham&#39;</span><span class="op">,</span> <span class="st">&#39;%s*spam%s*&#39;</span><span class="op">)</span> <span class="cf">do</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>   <span class="fu">print</span><span class="op">(</span><span class="st">&#39;&quot;&#39;</span><span class="op">..</span>s<span class="op">..</span><span class="st">&#39;&quot;&#39;</span><span class="op">)</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="cf">end</span></span>
<span id="cb9-4"><a href="#cb9-4"></a></span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="op">&gt;</span> <span class="st">&quot;Spam eggs&quot;</span></span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="op">&gt;</span> <span class="st">&quot;&quot;</span></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="op">&gt;</span> <span class="st">&quot;and ham&quot;</span></span></code></pre></div>
<hr />
<h3 id="glue.liness-opt---iter---s"><code>glue.lines(s[, opt]) -&gt; iter() -&gt; s</code></h3>
<p>Iterate the lines of a string.</p>
<ul>
<li>the lines are split at <code>\r\n</code>, <code>\r</code> and <code>\n</code> markers.</li>
<li>the line ending markers are included or excluded depending on the second arg, which can be <code>*L</code> (include line endings; default) or <code>*l</code> (exclude).</li>
<li>if the string is empty or doesn’t contain a line ending marker, it is iterated once.</li>
<li>if the string ends with a line ending marker, one more empty string is iterated.</li>
</ul>
<hr />
<h3 id="glue.trims---s"><code>glue.trim(s) -&gt; s</code></h3>
<p>Remove whitespace (defined as Lua pattern <code>"%s"</code>) from the beginning and end of a string.</p>
<hr />
<h3 id="glue.escsmode---pat"><code>glue.esc(s[,mode]) -&gt; pat</code></h3>
<p>Escape magic characters of the string <code>s</code> so that it can be used as a pattern to string matching functions.</p>
<ul>
<li>the optional argument <code>mode</code> can have the value <code>"*i"</code> (for case insensitive), in which case each alphabetical character in <code>s</code> will also be escaped as <code>"[aA]"</code> so that it matches both its lowercase and uppercase variants.</li>
<li>escapes embedded zeroes as the <code>%z</code> pattern.</li>
</ul>
<h4 id="uses-3">Uses</h4>
<ul>
<li>workaround for lack of pattern syntax for “this part of a match is an arbitrary string”</li>
<li>workaround for lack of a case-insensitive flag in pattern matching functions</li>
</ul>
<hr />
<h3 id="glue.tohexsnupper---s"><code>glue.tohex(s|n[,upper]) -&gt; s</code></h3>
<p>Convert a binary string or a Lua number to its hex representation.</p>
<ul>
<li>lowercase by default</li>
<li>uppercase if the arg <code>upper</code> is truthy</li>
<li>numbers must be in the unsigned 32 bit integer range</li>
</ul>
<hr />
<h3 id="glue.fromhexs---s"><code>glue.fromhex(s) -&gt; s</code></h3>
<p>Convert a hex string to its binary representation.</p>
<hr />
<h3 id="glue.startss-prefix---tf"><code>glue.starts(s, prefix) -&gt; t|f</code></h3>
<p>Find if string <code>s</code> starts with <code>prefix</code>. Implemented as <code>s:sub(1, #p) == p</code> which is 5x faster than <code>s:find'^...'</code> in LuaJIT 2.1 with JIT on (and about the same with jit off).</p>
<hr />
<h3 id="glue.endss-suffix---tf"><code>glue.ends(s, suffix) -&gt; t|f</code></h3>
<p>Find if string <code>s</code> ends with <code>suffix</code>.</p>
<hr />
<h2 id="iterators">Iterators</h2>
<h3 id="glue.collectiiterator---t"><code>glue.collect([i,]iterator) -&gt; t</code></h3>
<p>Iterate an iterator and collect its i’th return value of every step into a list.</p>
<ul>
<li>i defaults to 1</li>
</ul>
<h4 id="examples-5">Examples</h4>
<p>Implementation of <code>keys()</code> and <code>values()</code> in terms of <code>collect()</code></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb10-1"><a href="#cb10-1"></a>keys <span class="op">=</span> <span class="kw">function</span><span class="op">(</span>t<span class="op">)</span> <span class="cf">return</span> glue<span class="op">.</span>collect<span class="op">(</span><span class="fu">pairs</span><span class="op">(</span>t<span class="op">))</span> <span class="cf">end</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>values <span class="op">=</span> <span class="kw">function</span><span class="op">(</span>t<span class="op">)</span> <span class="cf">return</span> glue<span class="op">.</span>collect<span class="op">(</span><span class="dv">2</span><span class="op">,</span><span class="fu">pairs</span><span class="op">(</span>t<span class="op">))</span> <span class="cf">end</span></span></code></pre></div>
<p>Collecting string matches:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb11-1"><a href="#cb11-1"></a>s <span class="op">=</span> <span class="st">&#39;a,b,c,&#39;</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>t <span class="op">=</span> glue<span class="op">.</span>collect<span class="op">(</span>s<span class="op">:</span><span class="fu">gmatch</span><span class="st">&#39;(.-),&#39;</span><span class="op">)</span></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="cf">for</span> i<span class="op">=</span><span class="dv">1</span><span class="op">,#</span>t <span class="cf">do</span> <span class="fu">print</span><span class="op">(</span>t<span class="op">[</span>i<span class="op">])</span> <span class="cf">end</span></span>
<span id="cb11-4"><a href="#cb11-4"></a></span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="op">&gt;</span> a</span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="op">&gt;</span> b</span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="op">&gt;</span> c</span></code></pre></div>
<hr />
<h2 id="closures">Closures</h2>
<h3 id="glue.pass...---..."><code>glue.pass(...) -&gt; ...</code></h3>
<p>The identity function. Does nothing, returns back all arguments.</p>
<h4 id="uses-4">Uses</h4>
<p>Default value for optional callback arguments:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">function</span> urlopen<span class="op">(</span>url<span class="op">,</span> callback<span class="op">,</span> errback<span class="op">)</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>   callback <span class="op">=</span> callback <span class="kw">or</span> glue<span class="op">.</span>pass</span>
<span id="cb12-3"><a href="#cb12-3"></a>   errback <span class="op">=</span> errback <span class="kw">or</span> glue<span class="op">.</span>pass</span>
<span id="cb12-4"><a href="#cb12-4"></a>   <span class="op">...</span></span>
<span id="cb12-5"><a href="#cb12-5"></a>   callback<span class="op">()</span></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="cf">end</span></span></code></pre></div>
<h3 id="glue.noop"><code>glue.noop()</code></h3>
<p>Does nothing. Returns nothing.</p>
<hr />
<h3 id="glue.memoizef-narg---f"><code>glue.memoize(f[, narg]) -&gt; f</code></h3>
<h3 id="glue.memoize_multiretf-narg---f"><code>glue.memoize_multiret(f[, narg]) -&gt; f</code></h3>
<p>Memoization for functions with any number of arguments. <code>memoize()</code> supports functions with <em>one return value</em>. <code>memoize_multiret()</code> supports any function. Both support <code>nil</code> and <code>NaN</code> args and retvals.</p>
<p>Memoization guarantees to only call the original function <em>once</em> for the same combination of arguments.</p>
<p>Special attention is given to the vararg part of the function, if any. For instance, for a function <code>f(x, y, ...)</code>, calling <code>f(1)</code> is considered to be the same as calling <code>f(1, nil)</code>, but calling <code>f(1, nil)</code> is not the same as calling <code>f(1, nil, nil)</code>.</p>
<p>The optional <code>narg</code> fixates the function to always take exactly <code>narg</code> args regardless of how the function was defined.</p>
<h3 id="glue.tuplesnarg---f...---t"><code>glue.tuples([narg]) -&gt; f(...) -&gt; t</code></h3>
<p>Create a tuple space, which is a function that returns the same identity <code>t</code> for the same list of arguments. It is implemented as:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">local</span> tuple_mt <span class="op">=</span> <span class="op">{</span><span class="bu">__call</span> <span class="op">=</span> glue<span class="op">.</span>unpack<span class="op">}</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="kw">function</span> glue<span class="op">.</span>tuples<span class="op">(</span>narg<span class="op">)</span></span>
<span id="cb13-3"><a href="#cb13-3"></a>   <span class="cf">return</span> glue<span class="op">.</span>memoize<span class="op">(</span><span class="kw">function</span><span class="op">(...)</span></span>
<span id="cb13-4"><a href="#cb13-4"></a>      <span class="cf">return</span> <span class="fu">setmetatable</span><span class="op">(</span>glue<span class="op">.</span>pack<span class="op">(...),</span> tuple_mt<span class="op">)</span></span>
<span id="cb13-5"><a href="#cb13-5"></a>   <span class="cf">end</span><span class="op">)</span></span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="cf">end</span></span></code></pre></div>
<p>The result tuple can be expanded back by calling it: <code>t() -&gt; args...</code>.</p>
<hr />
<h2 id="objects">Objects</h2>
<h3 id="glue.inheritt-parent---t-glue.inheritt-nil---t"><code>glue.inherit(t, parent) -&gt; t</code> <br> <code>glue.inherit(t, nil) -&gt; t</code></h3>
<p>Set a table to inherit attributes from a parent table, or clear inheritance.</p>
<p>If the table has no metatable and inheritance has to be set, not cleared, then make it one.</p>
<h4 id="examples-6">Examples</h4>
<p>Logging mixin:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb14-1"><a href="#cb14-1"></a>AbstractLogger <span class="op">=</span> glue<span class="op">.</span>inherit<span class="op">({},</span> <span class="kw">function</span><span class="op">(</span>t<span class="op">,</span>k<span class="op">)</span> <span class="fu">error</span><span class="op">(</span><span class="st">&#39;abstract &#39;</span><span class="op">..</span>k<span class="op">)</span> <span class="cf">end</span><span class="op">)</span></span>
<span id="cb14-2"><a href="#cb14-2"></a>NullLogger <span class="op">=</span> glue<span class="op">.</span>inherit<span class="op">({</span>log <span class="op">=</span> <span class="kw">function</span><span class="op">()</span> <span class="cf">end</span><span class="op">},</span> AbstractLogger<span class="op">)</span></span>
<span id="cb14-3"><a href="#cb14-3"></a>PrintLogger <span class="op">=</span> glue<span class="op">.</span>inherit<span class="op">({</span>log <span class="op">=</span> <span class="kw">function</span><span class="op">(</span>self<span class="op">,...)</span> <span class="fu">print</span><span class="op">(...)</span> <span class="cf">end</span><span class="op">},</span> AbstractLogger<span class="op">)</span></span>
<span id="cb14-4"><a href="#cb14-4"></a></span>
<span id="cb14-5"><a href="#cb14-5"></a>HttpRequest <span class="op">=</span> glue<span class="op">.</span>inherit<span class="op">({</span></span>
<span id="cb14-6"><a href="#cb14-6"></a>   perform <span class="op">=</span> <span class="kw">function</span><span class="op">(</span>self<span class="op">,</span> url<span class="op">)</span></span>
<span id="cb14-7"><a href="#cb14-7"></a>      self<span class="op">:</span>log<span class="op">(</span><span class="st">&#39;Requesting&#39;</span><span class="op">,</span> url<span class="op">,</span> <span class="st">&#39;...&#39;</span><span class="op">)</span></span>
<span id="cb14-8"><a href="#cb14-8"></a>      <span class="op">...</span></span>
<span id="cb14-9"><a href="#cb14-9"></a>   <span class="cf">end</span></span>
<span id="cb14-10"><a href="#cb14-10"></a><span class="op">},</span> NullLogger<span class="op">)</span></span>
<span id="cb14-11"><a href="#cb14-11"></a></span>
<span id="cb14-12"><a href="#cb14-12"></a>LoggedRequest <span class="op">=</span> glue<span class="op">.</span>inherit<span class="op">({</span>log <span class="op">=</span> PrintLogger<span class="op">.</span>log<span class="op">},</span> HttpRequest<span class="op">)</span></span>
<span id="cb14-13"><a href="#cb14-13"></a></span>
<span id="cb14-14"><a href="#cb14-14"></a>LoggedRequest<span class="op">:</span>perform<span class="st">&#39;http://lua.org/&#39;</span></span>
<span id="cb14-15"><a href="#cb14-15"></a></span>
<span id="cb14-16"><a href="#cb14-16"></a><span class="op">&gt;</span> Requesting   http<span class="op">://</span>lua<span class="op">.</span>org<span class="op">/</span>   <span class="op">...</span></span></code></pre></div>
<p>Defining a module in Lua 5.2</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb15-1"><a href="#cb15-1"></a><span class="va">_ENV</span> <span class="op">=</span> glue<span class="op">.</span>inherit<span class="op">({},</span><span class="va">_G</span><span class="op">)</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="op">...</span></span></code></pre></div>
<p>To get the effect of static (single or multiple) inheritance, use <code>glue.update</code>.</p>
<p>When setting inheritance, you can pass in a function.</p>
<p>Unlike <code>glue.object</code>, this doesn’t add any keys to the object.</p>
<hr />
<h3 id="glue.objectsuper-t-...---t"><code>glue.object([super][, t], ...) -&gt; t</code></h3>
<p>Create a class or object from <code>t</code> (which defaults to <code>{}</code>) by setting <code>t</code> as its own metatable, setting <code>t.__index</code> to <code>super</code> and <code>t.__call</code> to <code>super.__call</code>. Extra args are passed to <code>glue.update(self, ...)</code>. This simple object model has the following qualities:</p>
<ul>
<li>the implementation is only 4 LOC (14 LOC if extra args are used) and can thus be copy-pasted into any module to avoid a dependency on the glue library.</li>
<li>funcall-style instantiation with <code>t(...)</code> which calls <code>t:__call(...)</code>.</li>
<li>small memory footprint (3 table slots and no additional tables).</li>
<li>subclassing from instances is allowed (prototype-based inheritance).</li>
<li><code>glue.object</code> can serve as a stub class/instance constructor: <code>t.__call = glue.object</code> (<code>t.new = glue.object</code> works too).</li>
<li>a separate constructor to be used only for subclassing can be made with the same pattern: <code>t.subclass = glue.object</code>.</li>
<li>virtual classes (aka dependency injection, aka nested inner classes whose fields and methods can be overridden by subclasses of the outer class): composite objects which need to instantiate other objects can be made extensible by exposing those objects’ classes as fields of the container class with <code>container_class.inner_class = inner_class</code> and instantiating with <code>self.inner_class(...)</code> so that replacing <code>inner_class</code> in a sub-class of <code>container_class</code> is possible. Moreso, instantiation with <code>self:inner_class(...)</code> (so with a colon) passes the container object to <code>inner_class</code>’s constructor automatically which allows referencing the container object from the inner object.</li>
<li>overriding syntax sugar so that the super class need not be referenced explicitly when overriding can be incorporated into the base class with <code>base.override = glue.override</code>.</li>
</ul>
<h3 id="glue.beforeclass-method_name-f"><code>glue.before(class, method_name, f)</code></h3>
<p>Modify a method such that it calls <code>f</code> at the beginning. <code>f</code> receives all the arguments passed to the method. <code>f</code>’s results are discarded.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb16-1"><a href="#cb16-1"></a>glue<span class="op">.</span>before<span class="op">(</span>foo<span class="op">,</span> <span class="st">&#39;bar&#39;</span><span class="op">,</span> <span class="kw">function</span><span class="op">(</span>self<span class="op">,</span> <span class="op">...)</span></span>
<span id="cb16-2"><a href="#cb16-2"></a>    <span class="op">...</span></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="cf">end</span><span class="op">)</span></span></code></pre></div>
<p>Alternatively,</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb17-1"><a href="#cb17-1"></a>foo<span class="op">.</span>before <span class="op">=</span> glue<span class="op">.</span>before</span>
<span id="cb17-2"><a href="#cb17-2"></a>foo<span class="op">:</span>before<span class="op">(</span><span class="st">&#39;bar&#39;</span><span class="op">,</span> <span class="kw">function</span><span class="op">(</span>self<span class="op">,</span> <span class="op">...)</span></span>
<span id="cb17-3"><a href="#cb17-3"></a>  <span class="op">...</span></span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="cf">end</span><span class="op">)</span></span></code></pre></div>
<h3 id="glue.afterclass-method_name-f"><code>glue.after(class, method_name, f)</code></h3>
<p>Modify a method such that it calls <code>f</code> at the end. <code>f</code> receives all the arguments passed to the method. The modified method returns what <code>f</code> returns.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb18-1"><a href="#cb18-1"></a>glue<span class="op">.</span>after<span class="op">(</span>foo<span class="op">,</span> <span class="st">&#39;bar&#39;</span><span class="op">,</span> <span class="kw">function</span><span class="op">(</span>self<span class="op">,</span> <span class="op">...)</span></span>
<span id="cb18-2"><a href="#cb18-2"></a>    <span class="op">...</span></span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="cf">end</span><span class="op">)</span></span></code></pre></div>
<p>Alternatively,</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb19-1"><a href="#cb19-1"></a>foo<span class="op">.</span>after <span class="op">=</span> glue<span class="op">.</span>after</span>
<span id="cb19-2"><a href="#cb19-2"></a>foo<span class="op">:</span>after<span class="op">(</span><span class="st">&#39;bar&#39;</span><span class="op">,</span> <span class="kw">function</span><span class="op">(</span>self<span class="op">,</span> <span class="op">...)</span></span>
<span id="cb19-3"><a href="#cb19-3"></a>  <span class="op">...</span></span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="cf">end</span><span class="op">)</span></span></code></pre></div>
<h3 id="glue.overrideclass-method_name-f"><code>glue.override(class, method_name, f)</code></h3>
<p>Override a method such that the new implementation only calls <code>f</code> as <code>f(inherited, self, ...)</code> where <code>inherited</code> is the old implementation. <code>f</code> receives all the method arguments and the method returns what <code>f</code> returns.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb20-1"><a href="#cb20-1"></a>glue<span class="op">.</span>override<span class="op">(</span>foo<span class="op">,</span> <span class="st">&#39;bar&#39;</span><span class="op">,</span> <span class="kw">function</span><span class="op">(</span>inherited<span class="op">,</span> self<span class="op">,</span> <span class="op">...)</span></span>
<span id="cb20-2"><a href="#cb20-2"></a>  <span class="op">...</span></span>
<span id="cb20-3"><a href="#cb20-3"></a>  <span class="kw">local</span> ret <span class="op">=</span> inherited<span class="op">(</span>self<span class="op">,</span> <span class="op">...)</span></span>
<span id="cb20-4"><a href="#cb20-4"></a>  <span class="op">...</span></span>
<span id="cb20-5"><a href="#cb20-5"></a><span class="cf">end</span><span class="op">)</span></span></code></pre></div>
<p>Alternatively,</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb21-1"><a href="#cb21-1"></a>foo<span class="op">.</span>override <span class="op">=</span> glue<span class="op">.</span>override</span>
<span id="cb21-2"><a href="#cb21-2"></a>foo<span class="op">:</span>override<span class="op">(</span><span class="st">&#39;bar&#39;</span><span class="op">,</span> <span class="kw">function</span><span class="op">(</span>inherited<span class="op">,</span> self<span class="op">,</span> <span class="op">...)</span></span>
<span id="cb21-3"><a href="#cb21-3"></a>  <span class="op">...</span></span>
<span id="cb21-4"><a href="#cb21-4"></a>  <span class="kw">local</span> ret <span class="op">=</span> inherited<span class="op">(</span>self<span class="op">,</span> <span class="op">...)</span></span>
<span id="cb21-5"><a href="#cb21-5"></a>  <span class="op">...</span></span>
<span id="cb21-6"><a href="#cb21-6"></a><span class="cf">end</span><span class="op">)</span></span></code></pre></div>
<hr />
<h2 id="io">I/O</h2>
<h3 id="glue.canopenfile-mode---filename-nil"><code>glue.canopen(file[, mode]) -&gt; filename | nil</code></h3>
<p>Checks whether a file exists and it’s available for reading or writing. The <code>mode</code> arg is the same as for [io.open] and defaults to ‘rb’.</p>
<hr />
<h3 id="glue.readfilefilenameformatopen---s-nil-err"><code>glue.readfile(filename[,format][,open]) -&gt; s | nil, err</code></h3>
<p>Read the contents of a file into a string.</p>
<ul>
<li><code>format</code> can be <code>"t"</code> in which case the file will be read in text mode (default is binary mode).</li>
<li><code>open</code> is the file open function which defaults to <code>io.open</code>.</li>
</ul>
<hr />
<h3 id="glue.readpipecmdformatopen---s-nil-err"><code>glue.readpipe(cmd[,format][,open]) -&gt; s | nil, err</code></h3>
<p>Read the output of a command into a string. The options are the same as for <code>glue.readfile</code>.</p>
<hr />
<h3 id="glue.replacefileoldpath-newpath"><code>glue.replacefile(oldpath, newpath)</code></h3>
<p>Move or rename a file. If <code>newpath</code> exists and it’s a file, it is replaced by the old file atomically. The operation can still fail under many circumstances like if <code>newpath</code> is a directory or if the files are in different filesystems or if <code>oldpath</code> is missing or locked, etc.</p>
<p>For consistent behavior across OSes, both paths should be absolute paths or just filenames.</p>
<p>On LuaJIT, this is implemented based on <code>MoveFileExA</code> on Windows.</p>
<hr />
<h3 id="glue.writefilefilenamestreadformattmpfile---ok-err"><code>glue.writefile(filename,s|t|read,[format],[tmpfile]) -&gt; ok, err</code></h3>
<p>Write the contents of a string, table or iterator to a file.</p>
<ul>
<li>the contents can be given as a string, an array of strings, or a function that returns a string or <code>nil</code> to signal end-of-stream.</li>
<li><code>format</code> can be <code>"t"</code> in which case the file will be written in text mode (default is binary mode).</li>
<li>if writing fails and <code>tmpfile</code> is not given, the file is removed; if <code>tmpfile</code> is given then the data is written to that file first which is then renamed to <code>filename</code> and if writing or renaming fails the temp file is removed and <code>filename</code> is not touched.</li>
</ul>
<hr />
<h3 id="glue.printerout-format---f"><code>glue.printer(out[, format]) -&gt; f</code></h3>
<p>Create a <code>print()</code>-like function which uses the function <code>out</code> to output its values and uses the optional <code>format</code> to format each value. For instance <code>glue.printer(io.write, tostring)</code> returns a function which behaves like the standard <code>print()</code> function.</p>
<hr />
<p><code>glue.time([t, [utc]]) -&gt; timestamp</code></p>
<p>Like <code>os.time()</code> but considers the time to be in UTC if either <code>utc</code> or <code>t.utc</code> is <code>true</code>.</p>
<hr />
<h2 id="errors">Errors</h2>
<h3 id="glue.assertvmessageformat_args..."><code>glue.assert(v[,message[,format_args...]])</code></h3>
<p>Like <code>assert</code> but supports formatting of the error message using <code>string.format()</code>.</p>
<p>This is better than <code>assert(v, string.format(message, format_args...))</code> because it avoids creating the message string when the assertion is true.</p>
<p><strong>CAVEAT</strong>: Unlike standard <code>assert()</code>, this only returns its first argument even when no message is given, to avoid returning the error message and its args when a message is given and the assertion is true. So the pattern <code>a, b = glue.assert(f())</code> doesn’t work.</p>
<h4 id="example">Example</h4>
<div class="sourceCode" id="cb22"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb22-1"><a href="#cb22-1"></a>glue<span class="op">.</span>assert<span class="op">(</span>depth <span class="op">&lt;=</span> maxdepth<span class="op">,</span> <span class="st">&#39;maximum depth %d exceeded&#39;</span><span class="op">,</span> maxdepth<span class="op">)</span></span></code></pre></div>
<hr />
<h3 id="glue.protectfunc---protected_func"><code>glue.protect(func) -&gt; protected_func</code></h3>
<p>In Lua, API functions conventionally signal errors by returning nil and an error message instead of raising errors. In the implementation however, using assert() and error() is preferred to coding explicit conditional flows to cover exceptional cases. Use this function to convert error-raising functions to nil,err-returning functions:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb23-1"><a href="#cb23-1"></a>protected_function <span class="op">=</span> glue<span class="op">.</span>protect<span class="op">(</span><span class="kw">function</span><span class="op">()</span></span>
<span id="cb23-2"><a href="#cb23-2"></a>   <span class="op">...</span></span>
<span id="cb23-3"><a href="#cb23-3"></a>   <span class="fu">assert</span><span class="op">(...)</span></span>
<span id="cb23-4"><a href="#cb23-4"></a>   <span class="op">...</span></span>
<span id="cb23-5"><a href="#cb23-5"></a>   <span class="fu">error</span><span class="op">(...)</span></span>
<span id="cb23-6"><a href="#cb23-6"></a>   <span class="op">...</span></span>
<span id="cb23-7"><a href="#cb23-7"></a>   <span class="cf">return</span> result_value</span>
<span id="cb23-8"><a href="#cb23-8"></a><span class="cf">end</span><span class="op">)</span></span>
<span id="cb23-9"><a href="#cb23-9"></a></span>
<span id="cb23-10"><a href="#cb23-10"></a><span class="kw">local</span> ret<span class="op">,</span> err <span class="op">=</span> protected_function<span class="op">()</span></span></code></pre></div>
<hr />
<h3 id="glue.pcallf...---true...-falsetraceback"><code>glue.pcall(f,...) -&gt; true,... | false,traceback</code></h3>
<p>With Lua’s pcall() you lose the stack trace, and with usual uses of pcall() you don’t want that. This variant appends the traceback to the error message.</p>
<blockquote>
<p><strong>NOTE</strong>: Lua 5.2 and LuaJIT only.</p>
</blockquote>
<hr />
<h3 id="glue.fpcallf...---result-niltraceback"><code>glue.fpcall(f,...) -&gt; result | nil,traceback</code></h3>
<h3 id="glue.fcallf...---result"><code>glue.fcall(f,...) -&gt; result</code></h3>
<p>These constructs bring the try/finally/except idiom to Lua. The first variant returns nil,error when errors occur while the second re-raises the error.</p>
<h4 id="example-1">Example</h4>
<div class="sourceCode" id="cb24"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb24-1"><a href="#cb24-1"></a><span class="kw">local</span> result <span class="op">=</span> glue<span class="op">.</span>fpcall<span class="op">(</span><span class="kw">function</span><span class="op">(</span>finally<span class="op">,</span> except<span class="op">,</span> <span class="op">...)</span></span>
<span id="cb24-2"><a href="#cb24-2"></a>  <span class="kw">local</span> temporary_resource <span class="op">=</span> acquire_resource<span class="op">()</span></span>
<span id="cb24-3"><a href="#cb24-3"></a>  finally<span class="op">(</span><span class="kw">function</span><span class="op">()</span> temporary_resource<span class="op">:</span>free<span class="op">()</span> <span class="cf">end</span><span class="op">)</span></span>
<span id="cb24-4"><a href="#cb24-4"></a>  <span class="op">...</span></span>
<span id="cb24-5"><a href="#cb24-5"></a>  <span class="kw">local</span> final_resource <span class="op">=</span> acquire_resource<span class="op">()</span></span>
<span id="cb24-6"><a href="#cb24-6"></a>  except<span class="op">(</span><span class="kw">function</span><span class="op">()</span> final_resource<span class="op">:</span>free<span class="op">()</span> <span class="cf">end</span><span class="op">)</span></span>
<span id="cb24-7"><a href="#cb24-7"></a>  <span class="op">...</span> code that might <span class="cf">break</span> <span class="op">...</span></span>
<span id="cb24-8"><a href="#cb24-8"></a>  <span class="cf">return</span> final_resource</span>
<span id="cb24-9"><a href="#cb24-9"></a><span class="cf">end</span><span class="op">,</span> <span class="op">...)</span></span></code></pre></div>
<hr />
<h2 id="modules">Modules</h2>
<h3 id="glue.modulename-parent---m-p"><code>glue.module([name, ][parent]) -&gt; M, P</code></h3>
<h3 id="glue.moduleparent-name---m-p"><code>glue.module([parent, ][name]) -&gt; M, P</code></h3>
<p>Create a module with a public and private namespace and set the environment of the calling function (not the global one!) to the module’s private namespace and return the namespaces. Cross-references between the namespaces are also created at <code>M._P</code>, <code>P._M</code>, <code>P._P</code> and <code>M._M</code>, so both <code>_P</code> and <code>_M</code> can be accessed directly from the new environment.</p>
<p><code>parent</code> controls what the namespaces will inherit and it can be either another module, in which case <code>M</code> inherits <code>parent</code> and <code>P</code> inherits <code>parent._P</code>, or it can be a string in which case the module to inherit is first required. <code>parent</code> defaults to <code>_M</code> so that calling <code>glue.module()</code> creates a submodule of the current module. If there’s no <code>_M</code> in the current environment then <code>P</code> inherits <code>_G</code> and <code>M</code> inherits nothing.</p>
<p>Specifying a <code>name</code> for the module either returns <code>package.loaded[name]</code> if it is set or creates a module, sets <code>package.loaded[name]</code> to it and returns that. This is useful for creating and referencing shared namespaces without having to make a Lua file and require that.</p>
<p>Naming the module also sets <code>P[name] = M</code> so that public symbols can be declared in <code>foo.bar</code> style instead of <code>_M.bar</code>.</p>
<p>Setting <code>foo.module = glue.module</code> makes module <code>foo</code> directly extensible by calling <code>foo:module'bar'</code> or <code>require'foo':module'bar'</code>.</p>
<h3 id="glue.autoloadt-submodules---t-glue.autoloadt-key-moduleloader---t"><code>glue.autoload(t, submodules) -&gt; t</code> <br> <code>glue.autoload(t, key, module|loader) -&gt; t</code></h3>
<p>Assign a metatable to <code>t</code> (or override an existing metatable’s <code>__index</code>) such that when a missing key is accessed, the module said to contain that key is require’d automatically.</p>
<p>The <code>submodules</code> argument is table of form <code>{key = module_name | load_function}</code> specifying the corresponding Lua module (or load function) that make each key available to <code>t</code>. The alternative syntax allows specifying the key - submodule associations one by one.</p>
<h4 id="motivation">Motivation</h4>
<p>Module autoloading allows splitting the implementation of a module in many submodules containing optional, self-contained functionality, without having to make this visible in the user API. This effectively disconnects how an API is modularized from how its implementation is modularized, allowing the implementation to be refactored at a later time without changing the API.</p>
<h4 id="example-2">Example</h4>
<p><strong>main module (foo.lua):</strong></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb25-1"><a href="#cb25-1"></a><span class="kw">local</span> <span class="kw">function</span> bar<span class="op">()</span> <span class="co">--function implemented in the main module</span></span>
<span id="cb25-2"><a href="#cb25-2"></a>  <span class="op">...</span></span>
<span id="cb25-3"><a href="#cb25-3"></a><span class="cf">end</span></span>
<span id="cb25-4"><a href="#cb25-4"></a></span>
<span id="cb25-5"><a href="#cb25-5"></a><span class="co">--create and return the module table</span></span>
<span id="cb25-6"><a href="#cb25-6"></a><span class="cf">return</span> glue<span class="op">.</span>autoload<span class="op">({</span></span>
<span id="cb25-7"><a href="#cb25-7"></a>   <span class="op">...</span></span>
<span id="cb25-8"><a href="#cb25-8"></a>   bar <span class="op">=</span> bar<span class="op">,</span></span>
<span id="cb25-9"><a href="#cb25-9"></a><span class="op">},</span> <span class="op">{</span></span>
<span id="cb25-10"><a href="#cb25-10"></a>   baz <span class="op">=</span> <span class="st">&#39;foo_extra&#39;</span><span class="op">,</span> <span class="co">--autoloaded function, implemented in module foo_extra</span></span>
<span id="cb25-11"><a href="#cb25-11"></a><span class="op">})</span></span></code></pre></div>
<p><strong>submodule (foo_extra.lua):</strong></p>
<div class="sourceCode" id="cb26"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb26-1"><a href="#cb26-1"></a><span class="kw">local</span> foo <span class="op">=</span> <span class="fu">require</span><span class="st">&#39;foo&#39;</span></span>
<span id="cb26-2"><a href="#cb26-2"></a></span>
<span id="cb26-3"><a href="#cb26-3"></a><span class="kw">function</span> foo<span class="op">.</span>baz<span class="op">(...)</span></span>
<span id="cb26-4"><a href="#cb26-4"></a>  <span class="op">...</span></span>
<span id="cb26-5"><a href="#cb26-5"></a><span class="cf">end</span></span></code></pre></div>
<p><strong>in usage:</strong></p>
<div class="sourceCode" id="cb27"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb27-1"><a href="#cb27-1"></a><span class="kw">local</span> foo <span class="op">=</span> <span class="fu">require</span><span class="st">&#39;foo&#39;</span></span>
<span id="cb27-2"><a href="#cb27-2"></a></span>
<span id="cb27-3"><a href="#cb27-3"></a>foo<span class="op">.</span>baz<span class="op">(...)</span> <span class="co">-- foo_extra was now loaded automatically</span></span></code></pre></div>
<hr />
<h3 id="glue.bin"><code>glue.bin</code></h3>
<p>Get the script’s directory. This allows finding files in the script’s directory regardless of the directory that Lua is started in.</p>
<p>For executables created with <a href="/bundle">bundle</a>, this is the executable’s directory.</p>
<h4 id="example-3">Example</h4>
<div class="sourceCode" id="cb28"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb28-1"><a href="#cb28-1"></a><span class="kw">local</span> foobar <span class="op">=</span> glue<span class="op">.</span>readfile<span class="op">(</span>glue<span class="op">.</span>bin <span class="op">..</span> <span class="st">&#39;/&#39;</span> <span class="op">..</span> file_near_this_script<span class="op">)</span></span></code></pre></div>
<h4 id="caveats">Caveats</h4>
<p>This only works if glue itself can already be found and required (chicken/egg problem). Also, the path is relative to the current directory, so this stops working as soon as the current directory is changed. Also, depending on how the process was started, this information might be missing or wrong since it’s set by the parent process. Better use <a href="/fs">fs</a>.exedir which has none of these problems.</p>
<hr />
<h3 id="glue.luapathpathindexext"><code>glue.luapath(path[,index[,ext]])</code></h3>
<p>Insert a Lua search pattern in <code>package.path</code> such that <code>require</code> will be able to load Lua modules from that path. The optional <code>index</code> arg specifies the insert position (default is 1, that is, before all existing paths; can be negative, to start counting from the end; can be the string ‘after’, which is the same as 0). The optional <code>ext</code> arg specifies the file extension to use (default is “lua”).</p>
<hr />
<h3 id="glue.cpathpathindex"><code>glue.cpath(path[,index])</code></h3>
<p>Insert a Lua search pattern in <code>package.cpath</code> such that <code>require</code> will be able to load Lua/C modules from that path. The <code>index</code> arg has the same meaning as with <code>glue.luapath</code>.</p>
<h4 id="example-4">Example</h4>
<div class="sourceCode" id="cb29"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb29-1"><a href="#cb29-1"></a>glue<span class="op">.</span>luapath<span class="op">(</span>glue<span class="op">.</span>bin<span class="op">)</span></span>
<span id="cb29-2"><a href="#cb29-2"></a>glue<span class="op">.</span>cpath<span class="op">(</span>glue<span class="op">.</span>bin<span class="op">)</span></span>
<span id="cb29-3"><a href="#cb29-3"></a></span>
<span id="cb29-4"><a href="#cb29-4"></a><span class="fu">require</span><span class="st">&#39;foo&#39;</span> <span class="co">--looking for `foo` in the same directory as the running script first</span></span></code></pre></div>
<hr />
<h2 id="allocation">Allocation</h2>
<h3 id="glue.freelistcreate-destroy---alloc-free"><code>glue.freelist([create], [destroy]) -&gt; alloc, free</code></h3>
<p>Returns <code>alloc() -&gt; e</code> and <code>free(e)</code> functions to allocate and deallocate Lua objects. The allocator returns the last freed object or calls <code>create()</code> to create a new one if the freelist is empty. <code>create</code> defaults to <code>function() return {} end</code>; <code>destroy</code> defaults to <code>glue.noop</code>.</p>
<h3 id="glue.bufferctype---allocminlenfalse---buf-capacity"><code>glue.buffer(ctype) -&gt; alloc(minlen|false) -&gt; buf, capacity</code></h3>
<p>(LuaJIT only) Return an allocation function that reuses or reallocates an internal buffer based on the <code>len</code> argument.</p>
<ul>
<li><code>ctype</code> must be a VLA: the returned buffer will have that type. this makes <code>glue.buffer(ctype)</code> compatible with <code>ffi.typeof(ctype)</code>.</li>
<li>the buffer only grows, it never shrinks and it only grows in powers of two steps.</li>
<li>the allocation function returns the buffer’s current capacity which can be equal or greater than the requested length.</li>
<li>the returned buffer is anchored by the allocation function. calling <code>alloc(false)</code> unanchores the buffer.</li>
<li>the contents of the buffer <em>are not preserved</em> between allocations but you <em>are allowed</em> to access both buffers between two consecutive allocations in order to do that yourself.</li>
</ul>
<hr />
<h2 id="ffi">FFI</h2>
<h3 id="glue.addrptr---number-string"><code>glue.addr(ptr) -&gt; number | string</code></h3>
<p>Convert the address of a pointer into a Lua number (or possibly string on 64bit platforms). This is useful for:</p>
<ul>
<li>hashing on pointer values (i.e. using pointers as table keys)</li>
<li>moving pointers in and out of Lua states when using <a href="/luastate">luastate</a></li>
</ul>
<h3 id="glue.ptrctypenumberstring---ptr"><code>glue.ptr([ctype,]number|string) -&gt; ptr</code></h3>
<p>Convert an address value stored as a Lua number or string to a cdata pointer, optionally specifying a ctype for the pointer (defaults to <code>void*</code>).</p>
<hr />
<h2 id="tips">Tips</h2>
<p>String functions are also in the <code>glue.string</code> table. You can extend the Lua <code>string</code> namespace:</p>
<pre><code>`glue.update(string, glue.string)`</code></pre>
<p>so you can use them as string methods:</p>
<pre><code>`s:trim()`</code></pre>
<h2 id="design">Design</h2>
<p><a href="/glue_design">glue_design</a></p>
