<h2 id="local-client-requirehttp_client"><code>local client = require'http_client'</code></h2>
<p>HTTP 1.1 coroutine-based async client in Lua. Supports persistent connections, pipelining, gzip compression, multiple client IPs, resource limits, auto-redirects, auto-retries, cookie jars, multi-level debugging, caching, cdata-buffer-based I/O.</p>
<p>GZip compression can be enabled with <code>client.http.zlib = require'zlib'</code>.</p>
<h2 id="status">Status</h2>
<p><warn>Work-in-progress.<warn></p>
<h2 id="api">API</h2>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>client:new(opt) -&gt; client</code></td>
<td style="text-align: left;">create a client object</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>client:request(opt) -&gt; req, res</code></td>
<td style="text-align: left;">make a HTTP request</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>client:close_all()</code></td>
<td style="text-align: left;">close all connections</td>
</tr>
</tbody>
</table>
<h3 id="clientnewopt---client"><code>client:new(opt) -&gt; client</code></h3>
<p>Create a client object. The <code>opt</code> table can contain:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>max_conn</code></td>
<td style="text-align: left;">limit the number of total connections</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>max_conn_per_target</code></td>
<td style="text-align: left;">limit the number of connections per <em>target</em></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>max_pipelined_requests</code></td>
<td style="text-align: left;">limit the number of pipelined requests</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>client_ips</code></td>
<td style="text-align: left;">a list of client IPs to assign to requests</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>max_retries</code></td>
<td style="text-align: left;">number of retries before giving up</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>max_redirects</code></td>
<td style="text-align: left;">number of redirects before giving up</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>debug</code></td>
<td style="text-align: left;"><code>true</code> to enable client-level debugging</td>
</tr>
</tbody>
</table>
<p>A <em>target</em> is a combination of (vhost, port, client_ip) on which one or more HTTP connections can be created subject to per-target limits.</p>
<h4 id="pipelined-requests">Pipelined requests</h4>
<p>A pipelined request is a request that is sent in advance of receiving the response for the previous request. Most HTTP servers accept these but in a limited number.</p>
<p>Spawning a new connection for a new request has a lot more initial latency than pipelining the request on an existing connection. On the other hand, pipelined responses come serialized and also the server might decide not to start processing pipelined requests as soon as they arrive because it would have to buffer the results before it can start sending them.</p>
<h3 id="clientrequestopt---req-res-make-a-http-request"><code>client:request(opt) -&gt; req, res</code> make a HTTP request</h3>
<p>Make a HTTP request. This must be called from a scheduled socket thread.</p>
<p>The <code>opt</code> table can contain:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">connection options</td>
<td style="text-align: left;">options to pass to <code>http:new()</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">request options</td>
<td style="text-align: left;">options to pass to <code>http:make_request()</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>client_ip</code></td>
<td style="text-align: left;">client ip to bind to (optional)</td>
</tr>
</tbody>
</table>
<h3 id="clientclose_all"><code>client:close_all()</code></h3>
<p>Close all connections. This must be called after the socket loop finishes.</p>
