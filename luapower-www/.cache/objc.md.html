<h2 id="local-objc-requireobjc"><code>local objc = require'objc'</code></h2>
<h2 id="features">Features</h2>
<ul>
<li>Coverage
<ul>
<li>full access to Cocoa classes, protocols, C functions, structs, enums, constants</li>
<li>access to methods, properties and ivars</li>
<li>creating classes and overriding methods</li>
<li>exploring and searching the Objective-C runtime</li>
</ul></li>
<li>Platforms
<ul>
<li>tested with <strong>OSX 10.7 to 10.12</strong> (<strong>32bit</strong> and <strong>64bit</strong>)</li>
</ul></li>
<li>Dependencies
<ul>
<li>none for Cocoa (XML parser included), <a href="/expat">expat</a> for non-standard bridgesupport files</li>
</ul></li>
<li>Type Bridging
<ul>
<li>methods and functions return Lua booleans</li>
<li>Lua numbers, strings and tables can be passed for NSNumber, NSStrings, NSArray and NSDictionary args</li>
<li>string names can be passed for class and selector args</li>
<li>Lua functions can be passed for block and function-pointer args without specifying a type signature</li>
<li>overriding methods does not require specifying the method type signature
<ul>
<li>method signatures are inferred from existing supermethods and conforming protocols
<ul>
<li>formal and informal protocols supported</li>
</ul></li>
</ul></li>
<li>function-pointer args on overriden methods and blocks can be called without specifying a type signature</li>
</ul></li>
<li>GC Bridging
<ul>
<li>attaching Lua variables to classes and objects
<ul>
<li>Lua variables follow the lifetime of Obj-C objects</li>
<li>Lua variables attached to classes are inherited</li>
</ul></li>
<li>automatic memory management of objects and blocks
<ul>
<li>blocks are refcounted and freed when their last owner releases them</li>
</ul></li>
</ul></li>
<li>Speed
<ul>
<li>aggressive caching all-around</li>
<li>no gc pressure in calling methods after the first invocation</li>
<li>fast, small embedded XML parser</li>
</ul></li>
</ul>
<h2 id="limitations">Limitations</h2>
<p>Blocks, function callbacks and overriden methods are based on ffi callbacks which come with some limitations:</p>
<ul>
<li>can’t access the vararg part of the function, for variadic functions/methods</li>
<li>can’t access the pass-by-value struct args or any arg after the first pass-by-value struct arg</li>
<li>can’t return structs by value</li>
</ul>
<p>To counter this, you can use <a href="/cbframe">cbframe</a> as a workaround. Enable it with <code>objc.debug.cbframe = true</code> and now all problem methods and blocks will receive a single arg: a pointer to a <a href="https://github.com/luapower/cbframe/blob/master/cbframe_x86_h.lua">D_CPUSTATE</a> struct that you have to pick up args from and write the return value into. Note that self isn’t passed in this case, the cpu state is the only arg.</p>
<h2 id="quick-tutorial">Quick Tutorial</h2>
<h3 id="loading-frameworks">Loading frameworks</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb1-1"><a href="#cb1-1"></a><span class="co">--load a framework by name; `objc.searchpaths` says where the frameworks are. you can also use full paths.</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="co">--classes and protocols are loaded, but also C constants, enums, functions, structs and even macros.</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>objc<span class="op">.</span>load<span class="st">&#39;Foundation&#39;</span></span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="co">--you can also load sub-frameworks like this:</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>objc<span class="op">.</span>load<span class="st">&#39;Carbon.HIToolbox&#39;</span></span>
<span id="cb1-7"><a href="#cb1-7"></a></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="co">--which is the same as using relative paths:</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>objc<span class="op">.</span>load<span class="st">&#39;Carbon.framework/Versions/Current/Frameworks/HIToolbox&#39;</span></span></code></pre></div>
<h3 id="creating-and-using-objects">Creating and using objects</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">--instantiate a class. the resulting object is retained and released on gc.</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="co">--you can call `release()` on it too, for a more speedy destruction.</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="kw">local</span> str <span class="op">=</span> objc<span class="op">.</span>NSString<span class="op">:</span>alloc<span class="op">():</span>initWithUTF8String<span class="st">&#39;wazza&#39;</span></span>
<span id="cb2-4"><a href="#cb2-4"></a></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="co">--call methods with multiple arguments using underscores for &#39;:&#39;. last underscore is optional.</span></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="co">--C constants, enums and functions are in the objc namespace too.</span></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="kw">local</span> result <span class="op">=</span> str<span class="op">:</span>compare_options<span class="op">(</span>otherStr<span class="op">,</span> objc<span class="op">.</span>NSLiteralSearch<span class="op">)</span></span></code></pre></div>
<h3 id="subclassing">Subclassing</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb3-1"><a href="#cb3-1"></a><span class="co">--create a derived class. when creating a class, say which protocols you wish it conforms to,</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="co">--so that you don&#39;t have to deal with type encodings when implementing its methods.</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>objc<span class="op">.</span>class<span class="op">(</span><span class="st">&#39;NSMainWindow&#39;</span><span class="op">,</span> <span class="st">&#39;NSWindw &lt;NSWindowDelegate&gt;&#39;</span><span class="op">)</span></span>
<span id="cb3-4"><a href="#cb3-4"></a></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="co">--add methods to your class. the selector `windowWillClose` is from the `NSWindowDelegate` protocol</span></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="co">--so its type encoding is inferred from the protocol definition.</span></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="kw">function</span> objc<span class="op">.</span>NSMainWindow<span class="op">:</span>windowWillClose<span class="op">(</span>notification<span class="op">)</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>   <span class="op">...</span></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="cf">end</span></span>
<span id="cb3-10"><a href="#cb3-10"></a></span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="co">--override existing methods. use `objc.callsuper` to call the supermethod.</span></span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="kw">function</span> objc<span class="op">.</span>NSMainWindow<span class="op">:</span>update<span class="op">()</span></span>
<span id="cb3-13"><a href="#cb3-13"></a>   <span class="op">...</span></span>
<span id="cb3-14"><a href="#cb3-14"></a>   <span class="cf">return</span> objc<span class="op">.</span>callsuper<span class="op">(</span>self<span class="op">,</span> <span class="st">&#39;update&#39;</span><span class="op">)</span></span>
<span id="cb3-15"><a href="#cb3-15"></a><span class="cf">end</span></span></code></pre></div>
<h3 id="converting-between-lua-and-obj-c-types">Converting between Lua and Obj-C types</h3>
<div class="sourceCode" id="cb4"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">local</span> str <span class="op">=</span> objc<span class="op">.</span>toobj<span class="st">&#39;hello&#39;</span>             <span class="co">--create a NSString from a Lua string</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="kw">local</span> num <span class="op">=</span> objc<span class="op">.</span>toobj<span class="op">(</span><span class="dv">3.14</span><span class="op">)</span>              <span class="co">--create a NSNumber from a Lua number</span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="kw">local</span> dic <span class="op">=</span> objc<span class="op">.</span>toobj<span class="op">{</span>a <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> b <span class="op">=</span> <span class="st">&#39;hi&#39;</span><span class="op">}</span>   <span class="co">--create a NSDictionary from a Lua table</span></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="kw">local</span> arr <span class="op">=</span> objc<span class="op">.</span>toobj<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">}</span>           <span class="co">--create a NSArray from a Lua table</span></span>
<span id="cb4-5"><a href="#cb4-5"></a></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="kw">local</span> s <span class="op">=</span> objc<span class="op">.</span>tolua<span class="op">(</span>str<span class="op">)</span></span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="kw">local</span> n <span class="op">=</span> objc<span class="op">.</span>tolua<span class="op">(</span>num<span class="op">)</span></span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="kw">local</span> t1 <span class="op">=</span> objc<span class="op">.</span>tolua<span class="op">(</span>dic<span class="op">)</span></span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="kw">local</span> t2 <span class="op">=</span> objc<span class="op">.</span>tolua<span class="op">(</span>arr<span class="op">)</span></span></code></pre></div>
<h3 id="adding-lua-variables-luavars">Adding Lua variables (luavars)</h3>
<div class="sourceCode" id="cb5"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb5-1"><a href="#cb5-1"></a><span class="co">--add Lua variables to your objects - their lifetime is tied to the lifetime of the object.</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="co">--you can also add class variables - they will be accessible through the objects too.</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>objc<span class="op">.</span>NSObject<span class="op">.</span>myClassVar <span class="op">=</span> <span class="st">&#39;I can live forever&#39;</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="kw">local</span> obj <span class="op">=</span> objc<span class="op">.</span>NSObject<span class="op">:</span>new<span class="op">()</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>obj<span class="op">.</span>myInstanceVar <span class="op">=</span> <span class="st">&#39;I live while obj lives&#39;</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>obj<span class="op">.</span>myClassVar <span class="op">=</span> <span class="dv">5</span> <span class="co">--change the class var (same value for all objects)</span></span></code></pre></div>
<h3 id="adding-lua-methods">Adding Lua methods</h3>
<p>Lua methods are just Lua variables which happen to have a function-type value. You can add them to a class or to an instance, but that doesn’t make them “class methods” or “instance methods” in OOP sense. Instead, this distinction comes about when you call them:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">function</span> objc<span class="op">.</span>NSObject<span class="op">:</span>myMethod<span class="op">()</span> <span class="cf">end</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="kw">local</span> str <span class="op">=</span> objc<span class="op">.</span>toobj<span class="st">&#39;hello&#39;</span>   <span class="co">--create a NSString instance, which is a NSObject</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>str<span class="op">:</span>myMethod<span class="op">()</span>                  <span class="co">--instance method (str passed as self)</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>objc<span class="op">.</span>NSString<span class="op">:</span>myMethod<span class="op">()</span>        <span class="co">--class method (NSString passed as self)</span></span></code></pre></div>
<p>As you can see, luavars attached to a class are also inherited.</p>
<blockquote>
<p>If this looks like a lot of magic, it is. The indexing rules for class and instance objects (i.e. getting and setting object and class fields) are pretty complex. Have a look at the API sections “object fields” and “class fields” to learn more.</p>
</blockquote>
<h3 id="accessing-properties-ivars">Accessing properties &amp; ivars</h3>
<div class="sourceCode" id="cb7"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb7-1"><a href="#cb7-1"></a><span class="co">--get and set class and instance properties using the dot notation.</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="kw">local</span> pr <span class="op">=</span> objc<span class="op">.</span>NSProgress<span class="op">:</span>progressWithTotalUnitCount<span class="op">(</span><span class="dv">123</span><span class="op">)</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="fu">print</span><span class="op">(</span>pr<span class="op">.</span>totalUnitCount<span class="op">)</span> <span class="co">--prints 123</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>pr<span class="op">.</span>totalUnitCount <span class="op">=</span> <span class="dv">321</span>  <span class="co">--sets it</span></span>
<span id="cb7-5"><a href="#cb7-5"></a></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="co">--get and set ivars using the dot notation.</span></span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="kw">local</span> obj <span class="op">=</span> objc<span class="op">.</span>NSDocInfo<span class="op">:</span>new<span class="op">()</span></span>
<span id="cb7-8"><a href="#cb7-8"></a>obj<span class="op">.</span>time <span class="op">=</span> <span class="dv">123</span></span>
<span id="cb7-9"><a href="#cb7-9"></a><span class="fu">print</span><span class="op">(</span>obj<span class="op">.</span>time<span class="op">)</span> <span class="co">--prints 123</span></span></code></pre></div>
<h3 id="creating-and-using-blocks">Creating and using blocks</h3>
<div class="sourceCode" id="cb8"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb8-1"><a href="#cb8-1"></a><span class="co">--blocks are created automatically when passing a Lua function where a block is expected.</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="co">--their lifetime is auto-managed, for both synchronous and asynchronous methods.</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="kw">local</span> str <span class="op">=</span> objc<span class="op">.</span>NSString<span class="op">:</span>alloc<span class="op">():</span>initWithUTF8String<span class="st">&#39;line1</span><span class="sc">\n</span><span class="st">line2</span><span class="sc">\n</span><span class="st">line3&#39;</span></span>
<span id="cb8-4"><a href="#cb8-4"></a>str<span class="op">:</span>enumerateLinesUsingBlock<span class="op">(</span><span class="kw">function</span><span class="op">(</span>line<span class="op">,</span> stop<span class="op">)</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>   <span class="fu">print</span><span class="op">(</span>line<span class="op">:</span>UTF8String<span class="op">())</span> <span class="co">--&#39;char *&#39; return values are also converted to Lua strings automatically</span></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="cf">end</span><span class="op">)</span></span>
<span id="cb8-7"><a href="#cb8-7"></a></span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="co">--however, blocks are slow to create and use ffi callbacks which are very limited in number.</span></span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="co">--create your blocks outside loops if possible, or call `collectgarbage()` every few hundred iterations.</span></span>
<span id="cb8-10"><a href="#cb8-10"></a></span>
<span id="cb8-11"><a href="#cb8-11"></a><span class="co">--create a block with its type signature inferred from usage.</span></span>
<span id="cb8-12"><a href="#cb8-12"></a><span class="co">--in this case, its type is that of arg#1 to NSString&#39;s `enumerateLinesUsingBlock` method.</span></span>
<span id="cb8-13"><a href="#cb8-13"></a><span class="kw">local</span> block <span class="op">=</span> objc<span class="op">.</span>toarg<span class="op">(</span>objc<span class="op">.</span>NSString<span class="op">,</span> <span class="st">&#39;enumerateLinesUsingBlock&#39;</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="kw">function</span><span class="op">(</span>line<span class="op">,</span> stop<span class="op">)</span></span>
<span id="cb8-14"><a href="#cb8-14"></a>   <span class="fu">print</span><span class="op">(</span>line<span class="op">:</span>UTF8String<span class="op">())</span></span>
<span id="cb8-15"><a href="#cb8-15"></a><span class="cf">end</span><span class="op">)</span></span>
<span id="cb8-16"><a href="#cb8-16"></a>str<span class="op">:</span>enumerateLinesUsingBlock<span class="op">(</span>block<span class="op">)</span></span>
<span id="cb8-17"><a href="#cb8-17"></a></span>
<span id="cb8-18"><a href="#cb8-18"></a><span class="co">--create a block with its method type encoding given manaully.</span></span>
<span id="cb8-19"><a href="#cb8-19"></a><span class="co">--for type encodings see:</span></span>
<span id="cb8-20"><a href="#cb8-20"></a><span class="co">--   https://code.google.com/p/jscocoa/wiki/MethodEncoding</span></span>
<span id="cb8-21"><a href="#cb8-21"></a><span class="kw">local</span> block <span class="op">=</span> objc<span class="op">.</span>block<span class="op">(</span><span class="kw">function</span><span class="op">(</span>line<span class="op">,</span> stop<span class="op">)</span></span>
<span id="cb8-22"><a href="#cb8-22"></a>   <span class="fu">print</span><span class="op">(</span>line<span class="op">:</span>UTF8String<span class="op">())</span></span>
<span id="cb8-23"><a href="#cb8-23"></a><span class="cf">end</span><span class="op">,</span> <span class="st">&#39;v@^B&#39;</span><span class="op">})</span> <span class="co">--retval is &#39;v&#39; (void), line is &#39;</span><span class="an">@&#39;</span><span class="co"> (object), stop is &#39;^B&#39; (pointer to BOOL)</span></span>
<span id="cb8-24"><a href="#cb8-24"></a>str<span class="op">:</span>enumerateLinesUsingBlock<span class="op">(</span>block<span class="op">)</span></span></code></pre></div>
<h3 id="more-goodies">More goodies</h3>
<p>Look up anything in Cocoa by a Lua pattern:</p>
<pre><code>   ./luajit objc_test.lua inspect_find foo</code></pre>
<p>Then inspect it:</p>
<pre><code>   ./luajit objc_test.lua inspect_class PAFootprint</code></pre>
<h3 id="even-more-goodies">Even more goodies</h3>
<p>Check out the unit test script, it also contains a few demos, not just tests.<br />
Check out the undocumented <code>objc_inspect</code> module, it has a simple cmdline inspection API.</p>
<h2 id="memory-management">Memory management</h2>
<p>Memory management in objc is automatic. Cocoa’s reference counting system is tied to the Lua’s garbage collector so that you don’t have to worry about retain/release. The integration is not air-tight though, so you need to know how it’s put together to avoid some tricky situations.</p>
<h3 id="strong-and-weak-references">Strong and weak references</h3>
<p>Ref. counting systems are fragile: they require that retain() and release() calls on an object be perfectly balanced. If they’re not, you’re toast. Thinking of object relationships in in terms of weak and strong references can help a lot with that.</p>
<p>A strong reference is a retained reference, guaranteed to be available until released. A weak reference is not retained and its availability depends on context.</p>
<p>A strong reference has a finalizer that calls release() when collected. A weak reference doesn’t have a finalizer.</p>
<p>Calling release() on a strong reference releases the reference, and removes the finalizer, turning it into a weak reference. You should not call release() on a weak reference.</p>
<h3 id="return-values-are-strong">Return values are strong</h3>
<p>Cocoa’s rules say that if you alloc an object, you get a strong (retained) reference on that object. Other method calls that return an object return a weak (non-retained) reference to that object. Lua retains all object return values so you always get a strong reference. This is required for the alloc():init() sequence to work, and it’s generally convenient.</p>
<h3 id="callback-arguments-are-weak">Callback arguments are weak</h3>
<p>Object arguments passed to overriden methods (including the self argument), blocks and function pointers, are weak references, not tied to Lua’s garbage collector. If you want to keep them around outside the scope of the callback, you need to retain them:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">local</span> strong_ref</span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="kw">function</span> MySubClass<span class="op">:</span>overridenMethod<span class="op">()</span></span>
<span id="cb11-3"><a href="#cb11-3"></a>   strong_ref <span class="op">=</span> self<span class="op">:</span>retain<span class="op">()</span> <span class="co">--self is a weak ref. it needs to be retained.</span></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="cf">end</span></span></code></pre></div>
<h3 id="luavars-and-object-ownership">Luavars and object ownership</h3>
<p>You should only use luavars on objects that you own. Luavars go away when the last strong reference to an object goes away. Setting Lua vars on an object with only weak references will leak those vars! Even worse, those vars might show up as vars of other objects!</p>
<h3 id="strongweak-ambiguities">Strong/weak ambiguities</h3>
<p>If you create a <code>NSWindow</code>, you don’t get an <em>unconditionally</em> retained reference to that window, contrary to Cocoa’s rules, because if the user closes the window, it is your reference that gets released. The binding doesn’t know about that and on gc it calls release again, giving you a crash at an unpredictable time (<code>export NSZombieEnabled=YES</code> can help here). To fix that you can either tell Cocoa that your ref is strong by calling <code>win:setReleasedWhenClosed(false)</code>, or tell the gc that your ref is weak by calling <code>ffi.gc(win, nil)</code>. If you chose the latter, remember that you can’t use luavars on that window!</p>
<h2 id="main-api">Main API</h2>
<table>
<colgroup>
<col style="width: 48%" />
<col style="width: 51%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>global objects</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>objc</code></td>
<td>namespace for loaded classes, C functions, function aliases, enums, constants, and this API</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>frameworks</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>objc.load(name|path[, option])</code></td>
<td>load a framework given its name or its full path<br />
option ‘notypes’: don’t load bridgesupport file</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>objc.searchpaths = {path1, ...}</code></td>
<td>search paths for frameworks</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>objc.findframework(name|path) -&gt; path, name</code></td>
<td>find a framework in searchpaths</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>classes</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>objc.class'name' -&gt; cls</code></td>
<td>class by name (<code>objc.class'Foo'</code> == <code>objc.Foo</code>)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>objc.class(obj) -&gt; cls</code></td>
<td>class of instance</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>objc.class('Foo', 'SuperFoo &lt;Protocol1, ...&gt;') -&gt; cls</code></td>
<td>create a class which conforms to protocols</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>objc.class('Foo', 'SuperFoo', 'Protocol1', ...) -&gt; cls</code></td>
<td>create a class (alternative way)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>objc.classname(cls) -&gt; s</code></td>
<td>class name</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>objc.isclass(x) -&gt; true|false</code></td>
<td>check for Class type</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>objc.isobj(x) -&gt; true|false</code></td>
<td>check for id type</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>objc.ismetaclass(cls) -&gt; true|false</code></td>
<td>check if the class is a metaclass</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>objc.superclass(cls|obj) -&gt; cls|nil</code></td>
<td>superclass</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>objc.metaclass(cls|obj) -&gt; cls</code></td>
<td>metaclass</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>objc.isa(cls|obj, supercls) -&gt; true|false</code></td>
<td>check the inheritance chain</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>objc.conforms(cls|obj, protocol) -&gt; true|false</code></td>
<td>check if a class conforms to a protocol</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>objc.responds(cls, sel) -&gt; true|false</code></td>
<td>check if instances of cls responds to a selector</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>objc.conform(cls, protocol) -&gt; true|false</code></td>
<td>declare that a class conforms to a protocol</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>object fields</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>obj.field</code><br />
<code>obj:method(args...)</code></td>
<td>access an instance field, i.e. try to get, in order:<br />
- an instance luavar<br />
- a readable instance property<br />
- an ivar<br />
- an instance method<br />
- a class field (see below)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>obj.field = val</code><br />
</td>
<td>set an instance field, i.e. try to set, in order:<br />
- an existing instance luavar<br />
- a writable instance property<br />
- an ivar<br />
- an existing class field (see below)<br />
- a new instance luavar</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>class fields</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>cls.field</code><br />
<code>cls:method(args...)</code></td>
<td>access a class field, i.e. try to get, in order:<br />
- a class luavar<br />
- a readable class property<br />
- a class method<br />
- a class luavar from a superclass</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>cls.field = val</code><br />
<code>function cls:method(args...) end</code></td>
<td>set a class field, i.e. try to set, in order:<br />
- an existing class luavar<br />
- a writable class property<br />
- an instance method<br />
- a conforming instance method<br />
- a class method<br />
- a conforming class method<br />
- an existing class luavar in a superclass<br />
- a new class luavar</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>type conversions</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>objc.tolua(x) -&gt; luatype</code></td>
<td>convert a NSNumber, NSString, NSDictionary, NSArray to a Lua number, string, table respectively. anything else passes through.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>objc.toobj(x) -&gt; objtype</code></td>
<td>convert a Lua number, string, or table to a NSNumber, NSString, NSDictionary, NSArray respectively. anything else passes through.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>objc.ipairs(arr) -&gt; next, arr, 0</code></td>
<td>ipairs for NSarray.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>overriding</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>objc.override(cls, sel, func[,mtype|ftype]) -&gt; true|false</code></td>
<td>override an existing method, or add a method which conforms to one of the conforming protocols. returns true if the method was found and overriden.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>objc.callsuper(obj, sel, args...) -&gt; retval</code></td>
<td>call the method implementation of the superclass of an object.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>objc.swizle(cls, sel1, sel2[, func])</code></td>
<td>swap implementations between sel1 and sel2. if sel2 is not an existing selector, func is required.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>selectors</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>objc.SEL(name|sel) -&gt; sel</code></td>
<td>create/find a selector by name</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>sel:name() -&gt; s</code></td>
<td>selector name (same as tostring(sel))</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>blocks and callbacks</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>objc.toarg(cls, sel, argindex, x) -&gt; objtype</code></td>
<td>convert a Lua value to an objc value - used specifically to create blocks and function callbacks with an appropriate type signature for a specific method argument.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>objc.block(func, mtype|ftype) -&gt; block</code></td>
<td>create a block with a specific type encoding.</td>
</tr>
</tbody>
</table>
<h2 id="reflection-api">Reflection API</h2>
<table>
<colgroup>
<col style="width: 48%" />
<col style="width: 51%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>protocols</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>objc.protocols() -&gt; iter() -&gt; proto</code></td>
<td>loaded protocols (formal or informal)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>objc.protocol(name|proto) -&gt; proto</code></td>
<td>get a protocol by name (formal or informal)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>proto:name() -&gt; s</code></td>
<td>protocol name (same as tostring(proto))</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>proto:protocols() -&gt; iter() -&gt; proto</code></td>
<td>inherited protocols</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>proto:properties() -&gt; iter() -&gt; prop</code></td>
<td>get properties (inherited ones not included)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>proto:property(proto, name, required, readonly) -&gt; prop</code></td>
<td>find a property</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>proto:methods(proto, inst, req) -&gt; iter() -&gt; sel, mtype</code></td>
<td>get method names and raw, non-annotated type encodings</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>proto:mtype(proto, sel, inst, req) -&gt; mtype</code></td>
<td>find a method and return its raw type encoding</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>proto:ctype(proto, sel, inst, req[, for_cb]) -&gt; ctype</code></td>
<td>find a method and return its C type encoding</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>classes</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>objc.classes() -&gt; iter() -&gt; cls</code></td>
<td>loaded classes</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>objc.protocols(cls) -&gt; iter() -&gt; proto</code></td>
<td>protocols which a class conforms to (formal or informal)</td>
</tr>
<tr class="even">
<td style="text-align: left;">objc.properties(cls) -&gt; iter() -&gt; prop`</td>
<td>instance properties<br />
use metaclass(cls) to get class properties</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>objc.property(cls, name) -&gt; prop</code></td>
<td>instance property by name (looks in superclasses too)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>objc.methods(cls) -&gt; iter() -&gt; meth</code></td>
<td>instance methods<br />
use metaclass(cls) to get class methods</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>objc.method(cls, name) -&gt; meth</code></td>
<td>instance method by name (looks in superclasses too)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>objc.ivars(cls) -&gt; iter() -&gt; ivar</code></td>
<td>ivars</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>objc.ivar(cls) -&gt; ivar</code></td>
<td>ivar by name (looks in superclasses too)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>properties</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>prop:name() -&gt; s</code></td>
<td>property name (same as tostring(prop))</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>prop:getter() -&gt; s</code></td>
<td>getter name</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>prop:setter() -&gt; s</code></td>
<td>setter name (if not readonly)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>prop:stype() -&gt; s</code></td>
<td>type encoding</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>prop:ctype() -&gt; s</code></td>
<td>C type encoding</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>prop:readonly() -&gt; true|false</code></td>
<td>readonly check</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>prop:ivar() -&gt; s</code></td>
<td>ivar name</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>methods</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>meth:selector() -&gt; sel</code></td>
<td>selector</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>meth:name() -&gt; s</code></td>
<td>selector name (same as tostring(meth))</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>meth:mtype() -&gt; s</code></td>
<td>type encoding</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>meth:implementation() -&gt; IMP</code></td>
<td>implementation (untyped)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>ivars</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>ivar:name() -&gt; s</code></td>
<td>name (same as tostring(ivar))</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>ivar:stype() -&gt; s</code></td>
<td>type encoding</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>ivar:ctype() -&gt; s</code></td>
<td>C type encoding</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>ivar:offset() -&gt; n</code></td>
<td>offset</td>
</tr>
</tbody>
</table>
<h2 id="debug-api">Debug API</h2>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>logging</strong></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>objc.debug.errors</code> (true)</td>
<td>log errors to stderr</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>objc.debug.printcdecl</code> (false)</td>
<td>print C declarations on stdout</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>objc.debug.logtopics= {topic = true}</code> (empty)</td>
<td>enable logging on some topic (see source code)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>objc.debug.errcount = {topic = count}</code></td>
<td>error counts</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>solving C name clashes</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>objc.debug.rename.string.foo = bar</code></td>
<td>load a string constant under a different name</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>objc.debug.rename.enum.foo = bar</code></td>
<td>load an enum under a different name</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>objc.debug.rename.typedef.foo = bar</code></td>
<td>load a type under a different name</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>objc.debug.rename.const.foo = bar</code></td>
<td>load a const under a different name</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>objc.debug.rename.function.foo = bar</code></td>
<td>load a global function under a different name</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>loading frameworks</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>objc.debug.loadtypes</code> (true)</td>
<td>load bridgesupport files</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>objc.debug.loaddeps</code> (false)</td>
<td>load dependencies per bridgesupport file (too many to be useful)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>objc.debug.lazyfuncs</code> (true)</td>
<td>cdef functions on the first call instead of on load</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>objc.debug.checkredef</code> (false)</td>
<td>check incompatible redefinition attempts (makes parsing slower)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>objc.debug.usexpat</code> (false)</td>
<td>use expat to parse bridgesupport files</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>gc bridging</strong></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>objc.debug.noretain.foo = true</code></td>
<td>declare that method <code>foo</code> already retains the object it returns</td>
</tr>
</tbody>
</table>
<h2 id="future-developments">Future developments</h2>
<blockquote>
<p>NOTE: I don’t plan to work on these, except on requests with a use case. Patches/pull requests welcome.</p>
</blockquote>
<h3 id="bridging">Bridging</h3>
<ul>
<li>function-pointer args on function-pointer args (recorded but not used - need use cases)</li>
<li>test for overriding a method that takes a function-pointer (not a block) arg and invoking that arg from the callback</li>
<li>auto-coercion of types for functions/methods with format strings, eg. NSLog
<ul>
<li>format string parser - apply to variadic functions and methods that have the <code>printf_format</code> attribute</li>
</ul></li>
<li>return pass-by-reference out parameters as multiple Lua return values
<ul>
<li>record type modifiers O=out, N=inout</li>
</ul></li>
<li>auto-allocation of out arrays using array type annotations
<ul>
<li><code>c_array_length_in_result</code> - array length is the return value</li>
<li><code>c_array_length_in_arg</code> - array length is an arg</li>
<li><code>c_array_delimited_by_null</code> - vararg ends in null - doesn’t luajit do that already?</li>
<li><code>c_array_of_variable_length</code> - ???</li>
<li><code>c_array_of_fixed_length</code> - specifies array size? doesn’t seem so</li>
</ul></li>
<li><code>sel_of_type</code>, <code>sel_of_type64</code> - use cases?</li>
<li>core foundation stuff
<ul>
<li><code>cftypes</code> xml node - use cases?</li>
<li><code>already_retained</code> flag</li>
</ul></li>
<li>operator overloading (need good use cases)</li>
</ul>
<h3 id="inspection">Inspection</h3>
<ul>
<li>list all frameworks in searchpaths</li>
<li>find framework in searchpaths</li>
<li>report conforming methods, where they come from and mark the required ones, especially required but not implemented</li>
<li>inspection of instances
<ul>
<li>print class, superclasses and protocols in one line</li>
<li>print values of luavars, ivars, properties</li>
<li>listing sections: ivars, properties, methods, with origin class/protocol for each</li>
</ul></li>
</ul>
<h3 id="type-cache">Type Cache</h3>
<p>The idea is to cache bridgesupport data into Lua files for faster loading of frameworks.</p>
<ul>
<li>one Lua cache file for each framework to be loaded with standard ‘require’
<ul>
<li>dependencies also loaded using standard ‘require’</li>
</ul></li>
<li>save dependency loading</li>
<li>save cdecls - there’s already a pretty printer and infrastructure for recording those</li>
<li>save constants and enums</li>
<li>save function wrappers</li>
<li>save mtas (find a more compact format for annotations containing only {retval=‘B’} ?)</li>
<li>save informal protocols</li>
</ul>
