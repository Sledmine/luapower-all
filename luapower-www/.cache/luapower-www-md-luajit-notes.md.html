<h2 id="luajit-assumptions">LuaJIT assumptions</h2>
<ul>
<li>LuaJIT hoists table accesses with constant keys out of loops, so caching module functions in locals is no longer (that much) needed.</li>
<li>LuaJIT hoists constant branches out of loops so it’s ok to specialize loop kernels with <code>if/else</code> or with <code>and/or</code> inside the loops.</li>
<li>LuaJIT inlines functions (except when using <code>...</code> and <code>select()</code> with non-constant indices), so it’s ok to specialize loop kernels with function composition.</li>
<li>multiplications and additions are cheaper than memory access, so storing the results of these operations in temporary variables might actually harm performance (more register spills).</li>
<li>there’s no difference between using <code>if/else</code> statements and using <code>and/or</code> expressions – they generate the same pipeline-trashing branch code (so avoid expressions with non-constant <code>and/or</code> operators in tight loops).</li>
<li>divisions are 4x slower than multiplications on x86, so when dividing by a constant, it helps turning <code>x / c</code> into <code>x * (1 / c)</code> since the constant expression is folded – LuaJIT does this already for power-of-2 constants where the semantics are equivalent.</li>
<li>the <code>%</code> operator is slow (it’s implemented in terms of <code>math.floor()</code> and division) and really kills hot loops; <code>math.fmod()</code> is even slower; I don’t have a solution for this except for <code>x % powers-of-two</code> which can be computed with bit ops.</li>
<li><code>__newindex</code> and <code>__index</code> metamethods must check the hash part of the table, so it’s best to avoid adding keys on the hash part of an array that uses these metamethods.</li>
<li>pointers and 64bit numbers are allocated on the heap unless sunk by allocation sinking, but that requires a small and predictable code path between pointer creation and usage so it’s not a general solution. So APIs that need to be fast should work with (base-pointer, offset) pairs instead of just pointers.</li>
</ul>
<blockquote>
<p>These are assumptions that I use throughout my code, so if any of them are wrong, please correct me.</p>
</blockquote>
<h2 id="luajit-gotchas">LuaJIT gotchas</h2>
<h3 id="nil-equality-of-pointers">Nil equality of pointers</h3>
<p><code>ptr == nil</code> evaluates to true for a NULL pointer. As innocent as this looks, this is actually a language extension because in Lua 5.1 world, objects of different types can’t ever be equal, so a cdata cannot be equal to nil.</p>
<p>This has two implications:</p>
<ol type="1">
<li>Lua-ffi cannot implement this for Lua 5.1, so compatibility with Lua cannot be acheived if this idiom is used.</li>
<li>The <code>if ptr then</code> idiom doesn’t work, although you’d expect that anything that <code>== nil</code> to pass the <code>if</code> test too.</li>
</ol>
<p>Both problems can be solved easily with a NULL-&gt;nil converter which must be applied on all pointers that flow into Lua (so mostly in constructors):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">local</span> <span class="cn">NULL</span> <span class="op">=</span> ffi<span class="op">.</span>new<span class="st">&#39;void*&#39;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">function</span> ptr<span class="op">(</span>p<span class="op">)</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>   <span class="cf">return</span> p <span class="op">~=</span> <span class="cn">NULL</span> <span class="kw">and</span> p <span class="kw">or</span> <span class="kw">nil</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="cf">end</span></span></code></pre></div>
<h3 id="reference-semantics-vs-value-semantics">Reference semantics vs value semantics</h3>
<p>The result of a[i] for an array of structs is a reference type, not a copy of the struct object. This is different than with arrays of scalars which have value semantics (scalars being immutable). This shows when trying to implement data structures that generalize on the element type. Because value semantics cannot be assumed, you can’t just use a[i] to pop a value out or for swapping values (the idiom <code>a[i], a[j] = a[j], a[i]</code> doesn’t work anymore).</p>
<h3 id="callbacks-and-jit">Callbacks and JIT</h3>
<p>JIT must be disabled on any Lua function that calls a C function that can trigger a ffi callback or you might get a “bad callback” exception. LuaJIT takes great pains to ensure that you won’t, but there’s no guarantee. This can turn into a “99% is worse than 0%” situation, because you might forget to disable the jit for a particular callback-triggering function only to get a crash in production.</p>
<p>There is no way that I know of to disable these jit barriers.</p>
<h3 id="callbacks-and-passing-structs-by-value">Callbacks and passing structs by value</h3>
<p>Currently, passing structs by value or returning structs by value is not supported with callbacks. This is generally not a problem, as most APIs don’t do that, with the notable exception of OSX APIs which do that <em>a lot</em>. <a href="/cbframe">cbframe</a> can be used as a workaround if you only have a few functions to fix, but it’s not a general solution yet.</p>
<h3 id="cdata-finalizer-call-order">CData finalizer call order</h3>
<p>Finalizers for cdata objects are called in undefined order. This means that objects anchored in a finalizer are not guaranteed to not be already finalized when that finalizer is called.</p>
<p>Consider this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">local</span> heap <span class="op">=</span> ffi<span class="op">.</span>gc<span class="op">(</span>CreateHeap<span class="op">(),</span> FreeHeap<span class="op">)</span></span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="kw">local</span> mem <span class="op">=</span> ffi<span class="op">.</span>gc<span class="op">(</span>CreateMem<span class="op">(</span>heap<span class="op">,</span> size<span class="op">),</span> <span class="kw">function</span><span class="op">(</span>mem<span class="op">)</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>   FreeMem<span class="op">(</span>heap<span class="op">,</span> mem<span class="op">)</span> <span class="co">-- heap anchored in mem&#39;s finalizer</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="cf">end</span><span class="op">)</span></span></code></pre></div>
<p>When the program exits, sometimes the heap’s finalizer is called before mem’s finalizer, even though mem’s finalizer holds a reference to heap. So it’s ok and useful to anchor objects in finalizers, but don’t <em>use</em> them in finalizers unless you can ensure that they’re still alive by other means.</p>
<p>There is no way to fix this with the current garbage collector.</p>
<h3 id="floating-point-numbers-from-outside">Floating point numbers from outside</h3>
<p>In places where an arbitrary bit pattern can be injected in place of a double or float, you have to normalize these to a standard NaN pattern (<code>0xffc00000</code> for floats and <code>0xfff8000000000000</code> for doubles), or check for NaN before accessing them. Failing to do so will get you a crash.</p>
<blockquote>
<p>The bit pattern for NaN is: exponent is all ‘1’, mantissa non-zero, sign ignored.</p>
</blockquote>
<p>Here’s a handy NaN checker for doubles:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">local</span> cast<span class="op">,</span> band<span class="op">,</span> bor <span class="op">=</span> ffi<span class="op">.</span>cast<span class="op">,</span> bit<span class="op">.</span>band<span class="op">,</span> bit<span class="op">.</span>bor</span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="kw">local</span> lohi_p <span class="op">=</span> ffi<span class="op">.</span>typeof<span class="op">(</span><span class="st">&quot;struct { int32_t &quot;</span><span class="op">..(</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>  ffi<span class="op">.</span>abi<span class="op">(</span><span class="st">&quot;le&quot;</span><span class="op">)</span> <span class="kw">and</span> <span class="st">&quot;lo, hi&quot;</span> <span class="kw">or</span> <span class="st">&quot;hi, lo&quot;</span><span class="op">)..</span><span class="st">&quot;; } *&quot;</span><span class="op">)</span></span>
<span id="cb3-4"><a href="#cb3-4"></a></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="kw">local</span> <span class="kw">function</span> double_isnan<span class="op">(</span>p<span class="op">)</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>   <span class="kw">local</span> q <span class="op">=</span> cast<span class="op">(</span>lohi_p<span class="op">,</span> p<span class="op">)</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>   <span class="cf">return</span> band<span class="op">(</span>q<span class="op">.</span>hi<span class="op">,</span> <span class="dv">0x7ff00000</span><span class="op">)</span> <span class="op">==</span> <span class="dv">0x7ff00000</span> <span class="kw">and</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>           bor<span class="op">(</span>q<span class="op">.</span>lo<span class="op">,</span> band<span class="op">(</span>q<span class="op">.</span>hi<span class="op">,</span> <span class="dv">0xfffff</span><span class="op">))</span> <span class="op">~=</span> <span class="dv">0</span></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="cf">end</span></span></code></pre></div>
<h3 id="luajit-memory-restrictions">LuaJIT memory restrictions</h3>
<p>LuaJIT must be in the lowest 2G of address space on x64. This applies to all GC-managed memory, including <code>ffi.new</code> allocations. Use malloc, mmap, etc. to access all memory without restrictions. Keep the low 2G of your address space free for LuaJIT (this might be hard depending on how you integrate LuaJIT in your app). Keep in mind that that if your memory usage on x86 is above 2G, your app is already not portable to x64. If you use malloc to fix this, watch out for problems with finalization order: finalization and freeing are the same thing now.</p>
<h2 id="luajit-tricks">LuaJIT tricks</h2>
<p>Pointer to number conversion that turns into a no-op when compiled:</p>
<pre><code>tonumber(ffi.cast(&#39;intptr_t&#39;, ffi.cast(&#39;void *&#39;, ptr)))</code></pre>
<p>Switching endianness of a 64bit integer (to use in conjunction with <code>ffi.abi'le'</code> and <code>ffi.abi'be'</code>):</p>
<pre><code>local p = ffi.cast(&#39;uint32*&#39;, int64_buffer)
p[0], p[1] = bit.bswap(p[1]), bit.bswap(p[0])</code></pre>
