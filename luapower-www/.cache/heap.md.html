<h2 id="local-heap-requireheap"><code>local heap = require'heap'</code></h2>
<p>Priority queues implemented as binary heaps. A binary heap is a binary tree that maintains the lowest (or highest) value at the root. The tree is laid as an implicit data structure over an array. Pushing and popping values from the heap is O(log(n)) and doesn’t use additional memory.</p>
<h2 id="api">API</h2>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>heap.heap(...) -&gt; push, pop</code></td>
<td style="text-align: left;">create a heap API from a stack API</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>heap.cdataheap(h) -&gt; h</code></td>
<td style="text-align: left;">create a fixed-capacity cdata-based heap</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>heap.valueheap([h]) -&gt; h</code></td>
<td style="text-align: left;">create a heap for Lua values</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>h:push(val) -&gt; index</code></td>
<td style="text-align: left;">push a value</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>h:pop([index][, dst]) -&gt; val</code></td>
<td style="text-align: left;">pop value (root value at default index 1)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>h:replace(index, val)</code></td>
<td style="text-align: left;">replace value at index</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>h:peek([index][, dst]) -&gt; val</code></td>
<td style="text-align: left;">get value without popping it</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>h:length() -&gt; n</code></td>
<td style="text-align: left;">number of elements in heap</td>
</tr>
</tbody>
</table>
<p><strong>API Notes</strong>:</p>
<ul>
<li>a cdata heap can hold size-1 elements (element 0 is used for swapping).</li>
<li>trying to push nil into a value heap raises an error.</li>
<li>values that compare equally are popped in random order.</li>
</ul>
<h3 id="heap.heappush-pop-swap-len-cmp---push-pop-rebalance"><code>heap.heap(push, pop, swap, len, cmp) -&gt; push, pop, rebalance</code></h3>
<p>Create a heap API:</p>
<pre><code>push(...) -&gt; i       drop a value into the heap and return its index
pop(i)               remove the value at index i (root is at index 1)
rebalance(i)         rebalance the heap after the value at i has been changed</code></pre>
<p>from a stack API:</p>
<pre><code>push(...)            add a value to the top of the stack
pop()                remove the value at the top of the stack
swap(i, j)           swap two values (indices start at 1)
len() -&gt; n           number of elements in stack
cmp(i, j) -&gt; bool    compare elements</code></pre>
<p>The heap can be a min-heap or max-heap depending on the comparison function. If cmp(i, j) returns a[i] &lt; a[j] then it’s a min-heap. Stack indices are assumed to be consecutive.</p>
<h3 id="heap.cdataheaph---h"><code>heap.cdataheap(h) -&gt; h</code></h3>
<p>Create a cdata heap over table <code>h</code> which must contain:</p>
<ul>
<li><code>size</code>: heap capacity (required).</li>
<li><code>ctype</code>: element type (required).</li>
<li><code>data</code>, <code>length</code>: a pre-allocated heap (optional).</li>
<li><code>cmp</code>: a comparison function (optional).</li>
</ul>
<h4 id="example">Example:</h4>
<div class="sourceCode" id="cb3"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">local</span> h <span class="op">=</span> heap<span class="op">.</span>cdataheap<span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>   size <span class="op">=</span> <span class="dv">100</span><span class="op">,</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>   ctype <span class="op">=</span> <span class="vs">[[</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="vs">      struct {</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="vs">         int priority;</span></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="vs">         int order;</span></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="vs">      }</span></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="vs">   ]],</span></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="vs">   cmp = function(a, b)</span></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="vs">      if a.priority == b.priority then</span></span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="vs">         return a.order &gt; b.order</span></span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="vs">      end</span></span>
<span id="cb3-13"><a href="#cb3-13"></a><span class="vs">      return a.priority &lt; b.priority</span></span>
<span id="cb3-14"><a href="#cb3-14"></a><span class="vs">   end}</span></span>
<span id="cb3-15"><a href="#cb3-15"></a><span class="vs">h:push{priority = 20, order = 1}</span></span>
<span id="cb3-16"><a href="#cb3-16"></a><span class="vs">h:push{priority = 10, order = 2}</span></span>
<span id="cb3-17"><a href="#cb3-17"></a><span class="vs">h:push{priority = 10, order = 3}</span></span>
<span id="cb3-18"><a href="#cb3-18"></a><span class="vs">h:push{priority = 20, order = 4}</span></span>
<span id="cb3-19"><a href="#cb3-19"></a><span class="vs">assert(h:pop().order == 3)</span></span>
<span id="cb3-20"><a href="#cb3-20"></a><span class="vs">assert(h:pop().order == 2)</span></span>
<span id="cb3-21"><a href="#cb3-21"></a><span class="vs">assert(h:pop().order == 4)</span></span>
<span id="cb3-22"><a href="#cb3-22"></a><span class="vs">assert(h:pop().order == 1)</span></span></code></pre></div>
<p>Note: the <code>order</code> field in this example is used to stabilize the order in which elements with the same priority are popped.</p>
<h3 id="heap.valueheaph---h"><code>heap.valueheap([h]) -&gt; h</code></h3>
<p>Create a value heap from table <code>h</code>, which can contain:</p>
<ul>
<li><code>cmp</code>: a comparison function (optional).</li>
<li>a pre-allocated heap in the array part of the table (optional).</li>
</ul>
<h4 id="example-1">Example:</h4>
<div class="sourceCode" id="cb4"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">local</span> h <span class="op">=</span> heap<span class="op">.</span>valueheap<span class="op">{</span>cmp <span class="op">=</span> <span class="kw">function</span><span class="op">(</span>a<span class="op">,</span> b<span class="op">)</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>      <span class="cf">return</span> a<span class="op">.</span>priority <span class="op">&lt;</span> b<span class="op">.</span>priority</span>
<span id="cb4-3"><a href="#cb4-3"></a>   <span class="cf">end</span><span class="op">}</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>h<span class="op">:</span>push<span class="op">{</span>priority <span class="op">=</span> <span class="dv">20</span><span class="op">,</span> etc <span class="op">=</span> <span class="st">&#39;bar&#39;</span><span class="op">}</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>h<span class="op">:</span>push<span class="op">{</span>priority <span class="op">=</span> <span class="dv">10</span><span class="op">,</span> etc <span class="op">=</span> <span class="st">&#39;foo&#39;</span><span class="op">}</span></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="fu">assert</span><span class="op">(</span>h<span class="op">:</span>pop<span class="op">().</span>priority <span class="op">==</span> <span class="dv">10</span><span class="op">)</span></span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="fu">assert</span><span class="op">(</span>h<span class="op">:</span>pop<span class="op">().</span>priority <span class="op">==</span> <span class="dv">20</span><span class="op">)</span></span></code></pre></div>
<h2 id="todo">TODO</h2>
<ul>
<li>heapifying the initial array</li>
<li>merge(h), meld(h)</li>
</ul>
