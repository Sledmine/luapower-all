<h2 id="local-coro-requirecoro"><code>local coro = require'coro'</code></h2>
<p>Symmetric coroutines are coroutines that can transfer control to any other coroutine, unlike Lua’s standard coroutines which can only yield back to their parent coroutine (and are called asymmetric coroutines or generators).</p>
<p>Rationale: writing coroutine-based generators over scheduled async callbacks (like the <code>read()</code> and <code>write()</code> methods of <a href="/socketloop">socketloop</a> sockets) in Lua is by default not possible because the callbacks would yield to the generator coroutine instead of yielding to their scheduler. This can be solved using a coroutine scheduler that allows transferring control both to the parent coroutine as well as transferring control to a specific coroutine.</p>
<p>This implementation is loosely based on the one from the paper <a href="http://www.inf.puc-rio.br/~roberto/docs/corosblp.pdf">Coroutines in Lua</a> with some important modifications:</p>
<ul>
<li><code>coro.transfer()</code> can transfer multiple values between coroutines (without pressuring the gc).</li>
<li>the coro module reimplements all the methods of the built-in coroutine module such that it can replace it entirely, which is what enables arbitrary transfering of control from inside standard-behaving coroutines.</li>
</ul>
<h2 id="api">API</h2>
<h3 id="coro.createf---thread"><code>coro.create(f) -&gt; thread</code></h3>
<p>Create a coroutine which can be started with either <code>coro.resume()</code> or with <code>coro.transfer()</code>.</p>
<h3 id="coro.transferthreadnil-...---..."><code>coro.transfer(thread|nil[, ...]) -&gt; ...</code></h3>
<p>Transfer control (and optionally any values) to a coroutine (or to the main thread if nil is passed for thread), suspending execution. The target coroutine either hasn’t started yet, in which case it is started and it receives the values as the arguments of its main function, or it’s suspended in a call to <code>coro.transfer()</code>, in which case it is resumed and receives the values as the return values of that call. Likewise, the coroutine which transfers execution will stay suspended until <code>coro.transfer()</code> is called again with it as target.</p>
<p>Errors raised inside a coroutine which was transferrred into are re-raised into the main thread.</p>
<p>A coroutine which was transferred into (as opposed to one which was resumed into) must finish by transferring control to another coroutine (or to the main thread), otherwise an error is raised.</p>
<h3 id="coro.install---old_coroutine_module"><code>coro.install() -&gt; old_coroutine_module</code></h3>
<p>Replace <code>_G.coroutine</code> with <code>coro</code> and return the old coroutine module. This enables coroutine-based-generators-over-abstract-I/O-callbacks from external modules to work with scheduled I/O functions which call <code>coro.transfer()</code> inside.</p>
<h3 id="coro.yield...---..."><code>coro.yield(...) -&gt; ...</code></h3>
<p>Behaves like standard <code>coroutine.yield()</code>. A coroutine that was transferred into via <code>coro.transfer()</code> cannot yield (an error is raised if attempted).</p>
<h3 id="coro.resume...---true-...-false-err-tracekback"><code>coro.resume(...) -&gt; true, ... | false, err, tracekback</code></h3>
<p>Behaves like standard <code>coroutine.resume()</code>. Adds a traceback as the third return value in case of error.</p>
<h3 id="coro.current---thread-nil"><code>coro.current() -&gt; thread | nil</code></h3>
<p>Behaves like standard <code>coroutine.current()</code>.</p>
<h3 id="coro.statusthread---status"><code>coro.status(thread) -&gt; status</code></h3>
<p>Behaves like standard <code>coroutine.status()</code>.</p>
<p><strong>NOTE:</strong> In this implementation <code>type(thread) == 'thread'</code>.</p>
<h2 id="why-it-works">Why it works</h2>
<p>This works because calling <code>resume()</code> from a thread is a lie: instead of resuming the thread it actually suspends the calling thread giving back control to the main thread which does the resuming. Since the calling thread is now suspended, it can later be resumed from any other thread.</p>
