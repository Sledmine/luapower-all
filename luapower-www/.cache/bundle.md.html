<h2 id="what-is">What is</h2>
<p>Bundle is a small framework for bundling together LuaJIT, Lua modules, Lua/C modules, DynASM/Lua modules, C libraries, and other static assets (and even directory listings) into a single fat executable. In its default configuration, it assumes luapower’s <a href="/building">toolchain</a> and <a href="/get-involved">directory layout</a> (meaning that you have to place your own code in the luapower directory) and it works on Windows, Linux and OSX, x86 and x64.</p>
<h2 id="usage">Usage</h2>
<pre><code> Compile and link together LuaJIT, Lua modules, Lua/C modules, C libraries,
 and other static assets into a single fat executable.

 Tested with MinGW, GCC and Clang on Windows, Linux and OSX respectively.
 Written by Cosmin Apreutesei. Public Domain.

 USAGE: mgit bundle options...

  -o  --output FILE                  Output executable (required)

  -m  --modules &quot;FILE1 ...&quot;|--all|-- Lua (or other) modules to bundle [1]
  -a  --alibs &quot;LIB1 ...&quot;|--all|--    Static libs to bundle            [2]
  -d  --dlibs &quot;LIB1 ...&quot;|--          Dynamic libs to link against     [3]
  -f  --frameworks &quot;FRM1 ...&quot;        Frameworks to link against (OSX) [4]
  -b  --bin-modules &quot;FILE1 ...&quot;      Files to force-bundle as binary blobs
  -b  --bin-modules &quot;FILE1 ...&quot;      Files to force-bundle as binary blobs
  -D  --dir-modules &quot;DIR1 ...&quot;       Directory listings to bundle as blobs

  -M  --main MODULE                  Module to run on start-up

  -m32                               Compile for 32bit (OSX)
  -z  --compress                     Compress the executable (needs UPX)
  -w  --no-console                   Hide console (Windows)
  -w  --no-console                   Make app bundle (OSX)
  -i  --icon FILE.ico                Set icon (Windows)
  -i  --icon FILE.png                Set icon (OSX; requires -w)
  -vi --versioninfo &quot;Name=Val;...&quot;   Set VERSIONINFO fields (Windows)
  -av --appversion VERSION|auto      Set bundle.appversion to VERSION
  -ar --apprepo REPO                 Git repo for -av auto

  -ll --list-lua-modules             List Lua modules
  -la --list-alibs                   List static libs (.a files)

  -C  --clean                        Ignore the object cache

  -v  --verbose                      Be verbose
  -h  --help                         Show this screen

 Passing -- clears the list of args for that option, including implicit args.

 [1] .lua, .c and .dasl are compiled, other files are added as blobs.

 [2] implicit static libs:           luajit
 [3] implicit dynamic libs:
 [4] implicit frameworks:            ApplicationServices
</code></pre>
<h3 id="examples">Examples</h3>
<pre><code># full bundle: all Lua modules plus all static libraries
mgit bundle -a --all -m --all -M main -o fat.exe

# minimal bundle: two Lua modules, one static lib, one blob
mgit bundle -a sha2 -m &#39;sha2 media/bmp/bg.bmp&#39; -M main -o lean.exe

# luajit frontend with built-in luasocket support, no main module
mgit bundle -a &#39;socket_core mime_core&#39; -m &#39;socket mime ltn12 socket/*.lua&#39; -o luajit.exe

# run the unit tests
mgit bundle-test</code></pre>
<p><strong>NOTE:</strong> Pass <code>-m --all</code> before any explicit <code>-m</code> arguments!<br> <strong>NOTE:</strong> Pass <code>-a --all</code> before any explicit <code>-a</code> arguments!</p>
<p><strong>TIP:</strong> Pass <code>-vi "FileDescription=..."</code> to set the process description that is shown in the Windows task manager.</p>
<h2 id="how-it-works">How it works</h2>
<p>The core of it is a slightly modifed LuaJIT frontend which adds two additional loaders at the end of the <code>package.loaders</code> table, enabling <code>require()</code> to load modules embedded in the executable when they are not found externally. <code>ffi.load()</code> is also modified to return <code>ffi.C</code> if the requested library is not found, allowing embedded C symbols to be used instead. Assets can be loaded with <code>bundle.load(filename)</code> (see below), subject to the same policy: load the embedded asset if the corresponding file is not present in the filesystem.</p>
<p>This allows mixed deployments where some modules and assets are bundled inside the exe and some are left outside, with no changes to the code and no rebundling needed. External modules always take precedence over embedded ones, allowing partial upgrades to the original executable without the need for a rebuild. Finally, one of the modules (embedded or not) can be specified to run instead of the usual REPL, effectively enabling single-executable app deployment for pure Lua apps with no glue C code needed.</p>
<h3 id="components">Components</h3>
<h4 id="mgitbundle.sh">.mgit/bundle.sh</h4>
<p>The bundler script: compiles and links modules to create a fat executable.</p>
<blockquote>
<p>The reason the script is hidden inside the .mgit dir is to allow you to use the same command <code>mgit bundle</code> on all platforms. In particular, mgit will drive the script using Git bash on Windows, if git is in your PATH. You can run the script directly without mgit of course but always run it from the root directory like this: <code>.mgit/bundle.sh</code> or move it there.</p>
</blockquote>
<h4 id="csrcbundleluajit.c">csrc/bundle/luajit.c</h4>
<p>The standard LuaJIT frontend, slightly modified to run stuff from <code>bundle.c</code>.</p>
<h4 id="csrcbundlebundle.c">csrc/bundle/bundle.c</h4>
<p>The bundle loader (C part):</p>
<ul>
<li>installs <code>require()</code> loaders on startup for loading embedded Lua and C modules</li>
<li>fills <code>_G.arg</code> with the command-line args</li>
<li>sets <code>_G.arg[-1]</code> to the name of the main script (<code>-M</code> option)</li>
<li>calls <code>require'bundle_loader'</code>, which means bundle_loader itself can be upgraded without a rebuild.</li>
</ul>
<h4 id="bundle_loader.lua">bundle_loader.lua</h4>
<p>The bundle loader (Lua part):</p>
<ul>
<li>sets <code>package.path</code> and <code>package.cpath</code> to only load modules relative to the exe’s dir and not look into the current directory.</li>
<li>overrides <code>ffi.load</code> to return <code>ffi.C</code> when a library is not found.</li>
<li>loads the main module, if any, per <code>arg[-1]</code></li>
<li>falls back to LuaJIT REPL if there’s no main module.</li>
</ul>
<p>One subtle point about <code>ffi.load</code> is that if a library was found in a system path but that library is also bundled, the bundled one will be used instead. So the search order is:</p>
<ol type="1">
<li>external shared library in the directory of the executable.</li>
<li>bundled library inside the executable.</li>
<li>external shared library in the system’s search path.</li>
</ol>
<h4 id="bundle.lua">bundle.lua</h4>
<p>Optional module with an API for loading embedded binary files:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>bundle.canopen(file) -&gt; t|f</code></td>
<td style="text-align: left;">check if a file exists and can be opened</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>bundle.load(filename) -&gt; string</code></td>
<td style="text-align: left;">load a file</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>bundle.mmap(filename) -&gt; mmap</code></td>
<td style="text-align: left;">memory-map a file</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>mmap.data</code></td>
<td style="text-align: left;">pointer to file data</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>mmap.size</code></td>
<td style="text-align: left;">file size</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>mmap:close()</code></td>
<td style="text-align: left;">close the mmap object</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>bundle.fs_open(filename) -&gt; f</code></td>
<td style="text-align: left;">open a file with <a href="/fs">fs</a></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>bundle.fs_dir(dirname) -&gt; d</code></td>
<td style="text-align: left;">open a dir with <a href="/fs">fs</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>bundle.appversion -&gt; string</code></td>
<td style="text-align: left;">app version from the <code>-av</code> cmdline option</td>
</tr>
</tbody>
</table>
<p><strong>NOTE:</strong> These functions look in the filesystem <em>first</em> and only if that fails they use the embedded blobs.</p>
<h2 id="search-paths">Search paths</h2>
<p>External files are looked for relative to the executable directory, regardless of the current directory, as follows:</p>
<ul>
<li>shared library dependencies (either link-time or ffi.load-time) are searched for in $exedir</li>
<li>Lua modules are searched for in $exedir</li>
<li>Lua/C modules are searched for in $exedir/clib</li>
<li>static assets are searched for in $exedir</li>
</ul>
<h2 id="a-note-on-compression">A note on compression</h2>
<p>Compressed executables cannot be mmapped, so they have to stay in RAM fully and always. If the bundled assets are large and compressible, better results can be acheived by compressing them individually or not compressing them at all, instead of compressing the entire exe. Compression also adds up to the exe’s loading time.</p>
<h2 id="lgpl-compliance">LGPL compliance</h2>
<p>Some libraries in luapower are LGPL (check the package table on the homepage to see which). LGPL does not normally allow static linking on closed-source projects, but because a bundled executable will always load the dynamic version of a bundled library if one is found in the directory of the exe, this behavior complies with the requirement of LGPL to provide a way for the end-user to use the app with a different version of the LGPL library without requiring you to ship the dynamic version of the library along with the executable.</p>
